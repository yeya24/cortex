// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/engine/distributed_execution/querierpb/querier.proto

package querierpb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Histogram_ResetHint int32

const (
	Histogram_UNKNOWN Histogram_ResetHint = 0
	Histogram_YES     Histogram_ResetHint = 1
	Histogram_NO      Histogram_ResetHint = 2
	Histogram_GAUGE   Histogram_ResetHint = 3
)

var Histogram_ResetHint_name = map[int32]string{
	0: "UNKNOWN",
	1: "YES",
	2: "NO",
	3: "GAUGE",
}

var Histogram_ResetHint_value = map[string]int32{
	"UNKNOWN": 0,
	"YES":     1,
	"NO":      2,
	"GAUGE":   3,
}

func (x Histogram_ResetHint) String() string {
	return proto.EnumName(Histogram_ResetHint_name, int32(x))
}

func (Histogram_ResetHint) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{7, 0}
}

type SeriesRequest struct {
	QueryID              uint64   `protobuf:"varint,1,opt,name=queryID,proto3" json:"queryID,omitempty"`
	FragmentID           uint64   `protobuf:"varint,2,opt,name=fragmentID,proto3" json:"fragmentID,omitempty"`
	Batchsize            int64    `protobuf:"varint,3,opt,name=batchsize,proto3" json:"batchsize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SeriesRequest) Reset()         { *m = SeriesRequest{} }
func (m *SeriesRequest) String() string { return proto.CompactTextString(m) }
func (*SeriesRequest) ProtoMessage()    {}
func (*SeriesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{0}
}
func (m *SeriesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeriesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeriesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeriesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeriesRequest.Merge(m, src)
}
func (m *SeriesRequest) XXX_Size() int {
	return m.Size()
}
func (m *SeriesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SeriesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SeriesRequest proto.InternalMessageInfo

func (m *SeriesRequest) GetQueryID() uint64 {
	if m != nil {
		return m.QueryID
	}
	return 0
}

func (m *SeriesRequest) GetFragmentID() uint64 {
	if m != nil {
		return m.FragmentID
	}
	return 0
}

func (m *SeriesRequest) GetBatchsize() int64 {
	if m != nil {
		return m.Batchsize
	}
	return 0
}

type NextRequest struct {
	QueryID              uint64   `protobuf:"varint,1,opt,name=queryID,proto3" json:"queryID,omitempty"`
	FragmentID           uint64   `protobuf:"varint,2,opt,name=fragmentID,proto3" json:"fragmentID,omitempty"`
	Batchsize            int64    `protobuf:"varint,3,opt,name=batchsize,proto3" json:"batchsize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NextRequest) Reset()         { *m = NextRequest{} }
func (m *NextRequest) String() string { return proto.CompactTextString(m) }
func (*NextRequest) ProtoMessage()    {}
func (*NextRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{1}
}
func (m *NextRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextRequest.Merge(m, src)
}
func (m *NextRequest) XXX_Size() int {
	return m.Size()
}
func (m *NextRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NextRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NextRequest proto.InternalMessageInfo

func (m *NextRequest) GetQueryID() uint64 {
	if m != nil {
		return m.QueryID
	}
	return 0
}

func (m *NextRequest) GetFragmentID() uint64 {
	if m != nil {
		return m.FragmentID
	}
	return 0
}

func (m *NextRequest) GetBatchsize() int64 {
	if m != nil {
		return m.Batchsize
	}
	return 0
}

type SeriesBatch struct {
	OneSeries            []*OneSeries `protobuf:"bytes,1,rep,name=OneSeries,proto3" json:"OneSeries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SeriesBatch) Reset()         { *m = SeriesBatch{} }
func (m *SeriesBatch) String() string { return proto.CompactTextString(m) }
func (*SeriesBatch) ProtoMessage()    {}
func (*SeriesBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{2}
}
func (m *SeriesBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeriesBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeriesBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeriesBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeriesBatch.Merge(m, src)
}
func (m *SeriesBatch) XXX_Size() int {
	return m.Size()
}
func (m *SeriesBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SeriesBatch.DiscardUnknown(m)
}

var xxx_messageInfo_SeriesBatch proto.InternalMessageInfo

func (m *SeriesBatch) GetOneSeries() []*OneSeries {
	if m != nil {
		return m.OneSeries
	}
	return nil
}

type OneSeries struct {
	Labels               []*Label `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OneSeries) Reset()         { *m = OneSeries{} }
func (m *OneSeries) String() string { return proto.CompactTextString(m) }
func (*OneSeries) ProtoMessage()    {}
func (*OneSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{3}
}
func (m *OneSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OneSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OneSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OneSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OneSeries.Merge(m, src)
}
func (m *OneSeries) XXX_Size() int {
	return m.Size()
}
func (m *OneSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_OneSeries.DiscardUnknown(m)
}

var xxx_messageInfo_OneSeries proto.InternalMessageInfo

func (m *OneSeries) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

type StepVectorBatch struct {
	StepVectors          []*StepVector `protobuf:"bytes,1,rep,name=step_vectors,json=stepVectors,proto3" json:"step_vectors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StepVectorBatch) Reset()         { *m = StepVectorBatch{} }
func (m *StepVectorBatch) String() string { return proto.CompactTextString(m) }
func (*StepVectorBatch) ProtoMessage()    {}
func (*StepVectorBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{4}
}
func (m *StepVectorBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepVectorBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepVectorBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepVectorBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepVectorBatch.Merge(m, src)
}
func (m *StepVectorBatch) XXX_Size() int {
	return m.Size()
}
func (m *StepVectorBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_StepVectorBatch.DiscardUnknown(m)
}

var xxx_messageInfo_StepVectorBatch proto.InternalMessageInfo

func (m *StepVectorBatch) GetStepVectors() []*StepVector {
	if m != nil {
		return m.StepVectors
	}
	return nil
}

type StepVector struct {
	T                    int64       `protobuf:"varint,1,opt,name=t,proto3" json:"t,omitempty"`
	Sample_IDs           []uint64    `protobuf:"varint,2,rep,packed,name=sample_IDs,json=sampleIDs,proto3" json:"sample_IDs,omitempty"`
	Samples              []float64   `protobuf:"fixed64,3,rep,packed,name=samples,proto3" json:"samples,omitempty"`
	Histogram_IDs        []uint64    `protobuf:"varint,4,rep,packed,name=histogram_IDs,json=histogramIDs,proto3" json:"histogram_IDs,omitempty"`
	Histograms           []Histogram `protobuf:"bytes,5,rep,name=histograms,proto3" json:"histograms"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *StepVector) Reset()         { *m = StepVector{} }
func (m *StepVector) String() string { return proto.CompactTextString(m) }
func (*StepVector) ProtoMessage()    {}
func (*StepVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{5}
}
func (m *StepVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepVector.Merge(m, src)
}
func (m *StepVector) XXX_Size() int {
	return m.Size()
}
func (m *StepVector) XXX_DiscardUnknown() {
	xxx_messageInfo_StepVector.DiscardUnknown(m)
}

var xxx_messageInfo_StepVector proto.InternalMessageInfo

func (m *StepVector) GetT() int64 {
	if m != nil {
		return m.T
	}
	return 0
}

func (m *StepVector) GetSample_IDs() []uint64 {
	if m != nil {
		return m.Sample_IDs
	}
	return nil
}

func (m *StepVector) GetSamples() []float64 {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *StepVector) GetHistogram_IDs() []uint64 {
	if m != nil {
		return m.Histogram_IDs
	}
	return nil
}

func (m *StepVector) GetHistograms() []Histogram {
	if m != nil {
		return m.Histograms
	}
	return nil
}

type Label struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Label) Reset()         { *m = Label{} }
func (m *Label) String() string { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()    {}
func (*Label) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{6}
}
func (m *Label) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Label) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Label.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Label) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Label.Merge(m, src)
}
func (m *Label) XXX_Size() int {
	return m.Size()
}
func (m *Label) XXX_DiscardUnknown() {
	xxx_messageInfo_Label.DiscardUnknown(m)
}

var xxx_messageInfo_Label proto.InternalMessageInfo

func (m *Label) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A native histogram, also known as a sparse histogram.
// Original design doc:
// https://docs.google.com/document/d/1cLNv3aufPZb3fNfaJgdaRBZsInZKKIHo9E6HinJVbpM/edit
// The appendix of this design doc also explains the concept of float
// histograms. This Histogram message can represent both, the usual
// integer histogram as well as a float histogram.
type Histogram struct {
	// Types that are valid to be assigned to Count:
	//
	//	*Histogram_CountInt
	//	*Histogram_CountFloat
	Count isHistogram_Count `protobuf_oneof:"count"`
	Sum   float64           `protobuf:"fixed64,3,opt,name=sum,proto3" json:"sum,omitempty"`
	// The schema defines the bucket schema. Currently, valid numbers
	// are -4 <= n <= 8. They are all for base-2 bucket schemas, where 1
	// is a bucket boundary in each case, and then each power of two is
	// divided into 2^n logarithmic buckets. Or in other words, each
	// bucket boundary is the previous boundary times 2^(2^-n). In the
	// future, more bucket schemas may be added using numbers < -4 or >
	// 8.
	Schema        int32   `protobuf:"zigzag32,4,opt,name=schema,proto3" json:"schema,omitempty"`
	ZeroThreshold float64 `protobuf:"fixed64,5,opt,name=zero_threshold,json=zeroThreshold,proto3" json:"zero_threshold,omitempty"`
	// Types that are valid to be assigned to ZeroCount:
	//
	//	*Histogram_ZeroCountInt
	//	*Histogram_ZeroCountFloat
	ZeroCount isHistogram_ZeroCount `protobuf_oneof:"zero_count"`
	// Negative Buckets.
	NegativeSpans []BucketSpan `protobuf:"bytes,8,rep,name=negative_spans,json=negativeSpans,proto3" json:"negative_spans"`
	// Use either "negative_deltas" or "negative_counts", the former for
	// regular histograms with integer counts, the latter for float
	// histograms.
	NegativeDeltas []int64   `protobuf:"zigzag64,9,rep,packed,name=negative_deltas,json=negativeDeltas,proto3" json:"negative_deltas,omitempty"`
	NegativeCounts []float64 `protobuf:"fixed64,10,rep,packed,name=negative_counts,json=negativeCounts,proto3" json:"negative_counts,omitempty"`
	// Positive Buckets.
	PositiveSpans []BucketSpan `protobuf:"bytes,11,rep,name=positive_spans,json=positiveSpans,proto3" json:"positive_spans"`
	// Use either "positive_deltas" or "positive_counts", the former for
	// regular histograms with integer counts, the latter for float
	// histograms.
	PositiveDeltas []int64             `protobuf:"zigzag64,12,rep,packed,name=positive_deltas,json=positiveDeltas,proto3" json:"positive_deltas,omitempty"`
	PositiveCounts []float64           `protobuf:"fixed64,13,rep,packed,name=positive_counts,json=positiveCounts,proto3" json:"positive_counts,omitempty"`
	ResetHint      Histogram_ResetHint `protobuf:"varint,14,opt,name=reset_hint,json=resetHint,proto3,enum=querierpb.Histogram_ResetHint" json:"reset_hint,omitempty"`
	// timestamp is in ms format, see model/timestamp/timestamp.go for
	// conversion from time.Time to Prometheus timestamp.
	TimestampMs          int64    `protobuf:"varint,15,opt,name=timestamp_ms,json=timestampMs,proto3" json:"timestamp_ms,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Histogram) Reset()         { *m = Histogram{} }
func (m *Histogram) String() string { return proto.CompactTextString(m) }
func (*Histogram) ProtoMessage()    {}
func (*Histogram) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{7}
}
func (m *Histogram) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Histogram) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Histogram.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Histogram) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Histogram.Merge(m, src)
}
func (m *Histogram) XXX_Size() int {
	return m.Size()
}
func (m *Histogram) XXX_DiscardUnknown() {
	xxx_messageInfo_Histogram.DiscardUnknown(m)
}

var xxx_messageInfo_Histogram proto.InternalMessageInfo

type isHistogram_Count interface {
	isHistogram_Count()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isHistogram_ZeroCount interface {
	isHistogram_ZeroCount()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Histogram_CountInt struct {
	CountInt uint64 `protobuf:"varint,1,opt,name=count_int,json=countInt,proto3,oneof" json:"count_int,omitempty"`
}
type Histogram_CountFloat struct {
	CountFloat float64 `protobuf:"fixed64,2,opt,name=count_float,json=countFloat,proto3,oneof" json:"count_float,omitempty"`
}
type Histogram_ZeroCountInt struct {
	ZeroCountInt uint64 `protobuf:"varint,6,opt,name=zero_count_int,json=zeroCountInt,proto3,oneof" json:"zero_count_int,omitempty"`
}
type Histogram_ZeroCountFloat struct {
	ZeroCountFloat float64 `protobuf:"fixed64,7,opt,name=zero_count_float,json=zeroCountFloat,proto3,oneof" json:"zero_count_float,omitempty"`
}

func (*Histogram_CountInt) isHistogram_Count()           {}
func (*Histogram_CountFloat) isHistogram_Count()         {}
func (*Histogram_ZeroCountInt) isHistogram_ZeroCount()   {}
func (*Histogram_ZeroCountFloat) isHistogram_ZeroCount() {}

func (m *Histogram) GetCount() isHistogram_Count {
	if m != nil {
		return m.Count
	}
	return nil
}
func (m *Histogram) GetZeroCount() isHistogram_ZeroCount {
	if m != nil {
		return m.ZeroCount
	}
	return nil
}

func (m *Histogram) GetCountInt() uint64 {
	if x, ok := m.GetCount().(*Histogram_CountInt); ok {
		return x.CountInt
	}
	return 0
}

func (m *Histogram) GetCountFloat() float64 {
	if x, ok := m.GetCount().(*Histogram_CountFloat); ok {
		return x.CountFloat
	}
	return 0
}

func (m *Histogram) GetSum() float64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *Histogram) GetSchema() int32 {
	if m != nil {
		return m.Schema
	}
	return 0
}

func (m *Histogram) GetZeroThreshold() float64 {
	if m != nil {
		return m.ZeroThreshold
	}
	return 0
}

func (m *Histogram) GetZeroCountInt() uint64 {
	if x, ok := m.GetZeroCount().(*Histogram_ZeroCountInt); ok {
		return x.ZeroCountInt
	}
	return 0
}

func (m *Histogram) GetZeroCountFloat() float64 {
	if x, ok := m.GetZeroCount().(*Histogram_ZeroCountFloat); ok {
		return x.ZeroCountFloat
	}
	return 0
}

func (m *Histogram) GetNegativeSpans() []BucketSpan {
	if m != nil {
		return m.NegativeSpans
	}
	return nil
}

func (m *Histogram) GetNegativeDeltas() []int64 {
	if m != nil {
		return m.NegativeDeltas
	}
	return nil
}

func (m *Histogram) GetNegativeCounts() []float64 {
	if m != nil {
		return m.NegativeCounts
	}
	return nil
}

func (m *Histogram) GetPositiveSpans() []BucketSpan {
	if m != nil {
		return m.PositiveSpans
	}
	return nil
}

func (m *Histogram) GetPositiveDeltas() []int64 {
	if m != nil {
		return m.PositiveDeltas
	}
	return nil
}

func (m *Histogram) GetPositiveCounts() []float64 {
	if m != nil {
		return m.PositiveCounts
	}
	return nil
}

func (m *Histogram) GetResetHint() Histogram_ResetHint {
	if m != nil {
		return m.ResetHint
	}
	return Histogram_UNKNOWN
}

func (m *Histogram) GetTimestampMs() int64 {
	if m != nil {
		return m.TimestampMs
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Histogram) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Histogram_CountInt)(nil),
		(*Histogram_CountFloat)(nil),
		(*Histogram_ZeroCountInt)(nil),
		(*Histogram_ZeroCountFloat)(nil),
	}
}

// A BucketSpan defines a number of consecutive buckets with their
// offset. Logically, it would be more straightforward to include the
// bucket counts in the Span. However, the protobuf representation is
// more compact in the way the data is structured here (with all the
// buckets in a single array separate from the Spans).
type BucketSpan struct {
	Offset               int32    `protobuf:"zigzag32,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Length               uint32   `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BucketSpan) Reset()         { *m = BucketSpan{} }
func (m *BucketSpan) String() string { return proto.CompactTextString(m) }
func (*BucketSpan) ProtoMessage()    {}
func (*BucketSpan) Descriptor() ([]byte, []int) {
	return fileDescriptor_8c8902d5f321c304, []int{8}
}
func (m *BucketSpan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BucketSpan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BucketSpan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BucketSpan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BucketSpan.Merge(m, src)
}
func (m *BucketSpan) XXX_Size() int {
	return m.Size()
}
func (m *BucketSpan) XXX_DiscardUnknown() {
	xxx_messageInfo_BucketSpan.DiscardUnknown(m)
}

var xxx_messageInfo_BucketSpan proto.InternalMessageInfo

func (m *BucketSpan) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BucketSpan) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func init() {
	proto.RegisterEnum("querierpb.Histogram_ResetHint", Histogram_ResetHint_name, Histogram_ResetHint_value)
	proto.RegisterType((*SeriesRequest)(nil), "querierpb.SeriesRequest")
	proto.RegisterType((*NextRequest)(nil), "querierpb.NextRequest")
	proto.RegisterType((*SeriesBatch)(nil), "querierpb.SeriesBatch")
	proto.RegisterType((*OneSeries)(nil), "querierpb.OneSeries")
	proto.RegisterType((*StepVectorBatch)(nil), "querierpb.StepVectorBatch")
	proto.RegisterType((*StepVector)(nil), "querierpb.StepVector")
	proto.RegisterType((*Label)(nil), "querierpb.Label")
	proto.RegisterType((*Histogram)(nil), "querierpb.Histogram")
	proto.RegisterType((*BucketSpan)(nil), "querierpb.BucketSpan")
}

func init() {
	proto.RegisterFile("pkg/engine/distributed_execution/querierpb/querier.proto", fileDescriptor_8c8902d5f321c304)
}

var fileDescriptor_8c8902d5f321c304 = []byte{
	// 828 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xdd, 0x8e, 0xdb, 0x54,
	0x10, 0xce, 0x59, 0x3b, 0x49, 0x3d, 0xf9, 0xd9, 0xf4, 0x68, 0xa9, 0xac, 0x88, 0x86, 0xd4, 0x08,
	0xb0, 0x10, 0x4a, 0x60, 0x11, 0x52, 0xb5, 0x82, 0x4a, 0x0d, 0x29, 0xdd, 0xa8, 0x90, 0x15, 0x67,
	0x29, 0x08, 0x6e, 0x22, 0x27, 0x3b, 0xeb, 0x58, 0xf5, 0x5f, 0x7d, 0x8e, 0x57, 0xa5, 0x4f, 0x00,
	0xcf, 0xc1, 0x2b, 0xf0, 0x10, 0xbd, 0x44, 0xe2, 0x1e, 0xa1, 0x7d, 0x12, 0x74, 0x8e, 0xed, 0x63,
	0xa3, 0xed, 0x45, 0x6f, 0x7a, 0x37, 0xf3, 0xcd, 0xf7, 0x4d, 0x3e, 0x8f, 0x27, 0x63, 0xb8, 0x9f,
	0x3e, 0xf3, 0xe7, 0x18, 0xfb, 0x41, 0x8c, 0xf3, 0x8b, 0x80, 0x8b, 0x2c, 0xd8, 0xe6, 0x02, 0x2f,
	0x36, 0xf8, 0x02, 0x77, 0xb9, 0x08, 0x92, 0x78, 0xfe, 0x3c, 0xc7, 0x2c, 0xc0, 0x2c, 0xdd, 0x56,
	0xd1, 0x2c, 0xcd, 0x12, 0x91, 0x50, 0x4b, 0x17, 0xc6, 0x47, 0x7e, 0xe2, 0x27, 0x0a, 0x9d, 0xcb,
	0xa8, 0x20, 0x38, 0x3e, 0x0c, 0xce, 0x25, 0x83, 0x33, 0x7c, 0x9e, 0x23, 0x17, 0xd4, 0x86, 0xae,
	0xd4, 0xfc, 0xba, 0x5a, 0xda, 0x64, 0x4a, 0x5c, 0x93, 0x55, 0x29, 0x9d, 0x00, 0x5c, 0x66, 0x9e,
	0x1f, 0x61, 0x2c, 0x56, 0x4b, 0xfb, 0x40, 0x15, 0x1b, 0x08, 0x7d, 0x17, 0xac, 0xad, 0x27, 0x76,
	0x7b, 0x1e, 0xbc, 0x44, 0xdb, 0x98, 0x12, 0xd7, 0x60, 0x35, 0xe0, 0x20, 0xf4, 0xd6, 0xf8, 0x42,
	0xbc, 0xed, 0x9f, 0x79, 0x08, 0xbd, 0xe2, 0x79, 0x16, 0x12, 0xa2, 0xc7, 0x60, 0x9d, 0xc5, 0x58,
	0x20, 0x36, 0x99, 0x1a, 0x6e, 0xef, 0xf8, 0x68, 0xa6, 0x67, 0x32, 0xd3, 0x35, 0x56, 0xd3, 0x9c,
	0x2f, 0x1a, 0x1a, 0xea, 0x42, 0x27, 0xf4, 0xb6, 0x18, 0x56, 0xea, 0x51, 0x43, 0xfd, 0xad, 0x2c,
	0xb0, 0xb2, 0xee, 0x3c, 0x81, 0xc3, 0x73, 0x81, 0xe9, 0x8f, 0xb8, 0x13, 0x49, 0x56, 0xfc, 0xfa,
	0x7d, 0xe8, 0x73, 0x81, 0xe9, 0xe6, 0x4a, 0x61, 0x55, 0x8b, 0x77, 0x1a, 0x2d, 0x6a, 0x05, 0xeb,
	0x71, 0x1d, 0x73, 0xe7, 0x4f, 0x02, 0x50, 0xd7, 0x68, 0x1f, 0x88, 0x50, 0x73, 0x32, 0x18, 0x11,
	0xf4, 0x2e, 0x00, 0xf7, 0xa2, 0x34, 0xc4, 0xcd, 0x6a, 0xc9, 0xed, 0x83, 0xa9, 0xe1, 0x9a, 0xcc,
	0x2a, 0x90, 0xd5, 0x92, 0xcb, 0xd1, 0x16, 0x09, 0xb7, 0x8d, 0xa9, 0xe1, 0x12, 0x56, 0xa5, 0xf4,
	0x7d, 0x18, 0xec, 0x03, 0x2e, 0x12, 0x3f, 0xf3, 0x22, 0xa5, 0x35, 0x95, 0xb6, 0xaf, 0x41, 0x29,
	0x3f, 0x01, 0xd0, 0x39, 0xb7, 0xdb, 0x37, 0x66, 0x76, 0x5a, 0x15, 0x17, 0xe6, 0xab, 0x7f, 0xde,
	0x6b, 0xb1, 0x06, 0xdb, 0xf9, 0x0c, 0xda, 0x6a, 0x28, 0x94, 0x82, 0x19, 0x7b, 0x11, 0x2a, 0xcf,
	0x16, 0x53, 0x31, 0x3d, 0x82, 0xf6, 0x95, 0x17, 0xe6, 0xa8, 0xde, 0xa9, 0xc5, 0x8a, 0xc4, 0xf9,
	0xbb, 0x0d, 0x96, 0x6e, 0x49, 0xef, 0x82, 0xb5, 0x4b, 0xf2, 0x58, 0x6c, 0x82, 0xb8, 0x78, 0x60,
	0xf3, 0xb4, 0xc5, 0x6e, 0x29, 0x68, 0x15, 0x0b, 0x7a, 0x0f, 0x7a, 0x45, 0xf9, 0x32, 0x4c, 0x3c,
	0xa1, 0x1a, 0x91, 0xd3, 0x16, 0x03, 0x05, 0x7e, 0x23, 0x31, 0x3a, 0x02, 0x83, 0xe7, 0x91, 0x5a,
	0x0c, 0xc2, 0x64, 0x48, 0xef, 0x40, 0x87, 0xef, 0xf6, 0x18, 0x79, 0xb6, 0x39, 0x25, 0xee, 0x6d,
	0x56, 0x66, 0xf4, 0x03, 0x18, 0xbe, 0xc4, 0x2c, 0xd9, 0x88, 0x7d, 0x86, 0x7c, 0x9f, 0x84, 0x17,
	0x76, 0x5b, 0x89, 0x06, 0x12, 0xfd, 0xa1, 0x02, 0xe9, 0x87, 0x25, 0xad, 0xf6, 0xd5, 0x51, 0xbe,
	0x08, 0xeb, 0x4b, 0xfc, 0xeb, 0xca, 0xdb, 0xc7, 0x30, 0x6a, 0xf0, 0x0a, 0x83, 0x5d, 0x65, 0x90,
	0xb0, 0xa1, 0x66, 0x16, 0x26, 0x17, 0x30, 0x8c, 0xd1, 0xf7, 0x44, 0x70, 0x85, 0x1b, 0x9e, 0x7a,
	0x31, 0xb7, 0x6f, 0xdd, 0x58, 0x8d, 0x45, 0xbe, 0x7b, 0x86, 0xe2, 0x3c, 0xf5, 0xe2, 0x72, 0xd0,
	0x83, 0x4a, 0x22, 0x31, 0x4e, 0x3f, 0x82, 0x43, 0xdd, 0xe3, 0x02, 0x43, 0xe1, 0x71, 0xdb, 0x9a,
	0x1a, 0x2e, 0x65, 0xba, 0xf5, 0x52, 0xa1, 0xff, 0x23, 0x2a, 0x73, 0xdc, 0x06, 0xb5, 0x17, 0x9a,
	0xa8, 0x9c, 0x71, 0xe9, 0x2a, 0x4d, 0x78, 0xd0, 0x70, 0xd5, 0x7b, 0x03, 0x57, 0x95, 0x44, 0xbb,
	0xd2, 0x3d, 0x4a, 0x57, 0xfd, 0xc2, 0x55, 0x05, 0xd7, 0xae, 0x34, 0xb1, 0x74, 0x35, 0x28, 0x5c,
	0x55, 0x70, 0xe9, 0xea, 0x2b, 0x80, 0x0c, 0x39, 0x8a, 0xcd, 0x5e, 0xce, 0x7e, 0x38, 0x25, 0xee,
	0xf0, 0x78, 0xf2, 0xba, 0x7d, 0x9c, 0x31, 0x49, 0x3b, 0x0d, 0x62, 0xc1, 0xac, 0xac, 0x0a, 0xe9,
	0x3d, 0xe8, 0x8b, 0x20, 0x42, 0x2e, 0xbc, 0x28, 0xdd, 0x44, 0xdc, 0x3e, 0x54, 0xff, 0xa2, 0x9e,
	0xc6, 0xbe, 0xe3, 0xce, 0x09, 0x58, 0x5a, 0x4a, 0x7b, 0xd0, 0x7d, 0xba, 0x7e, 0xb2, 0x3e, 0xfb,
	0x69, 0x3d, 0x6a, 0xd1, 0x2e, 0x18, 0x3f, 0x3f, 0x3a, 0x1f, 0x11, 0xda, 0x81, 0x83, 0xf5, 0xd9,
	0xe8, 0x80, 0x5a, 0xd0, 0x7e, 0xfc, 0xf0, 0xe9, 0xe3, 0x47, 0x23, 0x63, 0x6c, 0xfe, 0xf6, 0xc7,
	0x84, 0x2c, 0xba, 0xd0, 0x56, 0xee, 0x17, 0x7d, 0x80, 0xfa, 0xf5, 0x3b, 0x5f, 0x02, 0xd4, 0x93,
	0x92, 0x1b, 0x98, 0x5c, 0x5e, 0x72, 0x2c, 0x56, 0xfa, 0x36, 0x2b, 0x33, 0x89, 0x87, 0x18, 0xfb,
	0x62, 0xaf, 0x36, 0x79, 0xc0, 0xca, 0xec, 0xf8, 0x77, 0x02, 0xdd, 0xef, 0x8b, 0x07, 0xa4, 0x0f,
	0xa0, 0x53, 0x9e, 0x22, 0xbb, 0x79, 0x37, 0x9a, 0x37, 0x7b, 0x7c, 0xe7, 0x46, 0x45, 0xdd, 0x1f,
	0xa7, 0xf5, 0x29, 0xa1, 0x0f, 0xc0, 0x94, 0x77, 0x97, 0x36, 0x39, 0x8d, 0x43, 0x3c, 0x1e, 0xbf,
	0xf6, 0x1a, 0x69, 0xfd, 0xe2, 0xe4, 0xd5, 0xf5, 0x84, 0xfc, 0x75, 0x3d, 0x21, 0xff, 0x5e, 0x4f,
	0xc8, 0x2f, 0x9f, 0xcc, 0xe6, 0x6f, 0xfe, 0x2d, 0xda, 0x76, 0xd4, 0x37, 0xe6, 0xf3, 0xff, 0x02,
	0x00, 0x00, 0xff, 0xff, 0xed, 0x20, 0x10, 0x11, 0xc0, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QuerierClient is the client API for Querier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QuerierClient interface {
	Series(ctx context.Context, in *SeriesRequest, opts ...grpc.CallOption) (Querier_SeriesClient, error)
	Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (Querier_NextClient, error)
}

type querierClient struct {
	cc *grpc.ClientConn
}

func NewQuerierClient(cc *grpc.ClientConn) QuerierClient {
	return &querierClient{cc}
}

func (c *querierClient) Series(ctx context.Context, in *SeriesRequest, opts ...grpc.CallOption) (Querier_SeriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Querier_serviceDesc.Streams[0], "/querierpb.Querier/Series", opts...)
	if err != nil {
		return nil, err
	}
	x := &querierSeriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Querier_SeriesClient interface {
	Recv() (*SeriesBatch, error)
	grpc.ClientStream
}

type querierSeriesClient struct {
	grpc.ClientStream
}

func (x *querierSeriesClient) Recv() (*SeriesBatch, error) {
	m := new(SeriesBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *querierClient) Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (Querier_NextClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Querier_serviceDesc.Streams[1], "/querierpb.Querier/Next", opts...)
	if err != nil {
		return nil, err
	}
	x := &querierNextClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Querier_NextClient interface {
	Recv() (*StepVectorBatch, error)
	grpc.ClientStream
}

type querierNextClient struct {
	grpc.ClientStream
}

func (x *querierNextClient) Recv() (*StepVectorBatch, error) {
	m := new(StepVectorBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QuerierServer is the server API for Querier service.
type QuerierServer interface {
	Series(*SeriesRequest, Querier_SeriesServer) error
	Next(*NextRequest, Querier_NextServer) error
}

// UnimplementedQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedQuerierServer struct {
}

func (*UnimplementedQuerierServer) Series(req *SeriesRequest, srv Querier_SeriesServer) error {
	return status.Errorf(codes.Unimplemented, "method Series not implemented")
}
func (*UnimplementedQuerierServer) Next(req *NextRequest, srv Querier_NextServer) error {
	return status.Errorf(codes.Unimplemented, "method Next not implemented")
}

func RegisterQuerierServer(s *grpc.Server, srv QuerierServer) {
	s.RegisterService(&_Querier_serviceDesc, srv)
}

func _Querier_Series_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SeriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuerierServer).Series(m, &querierSeriesServer{stream})
}

type Querier_SeriesServer interface {
	Send(*SeriesBatch) error
	grpc.ServerStream
}

type querierSeriesServer struct {
	grpc.ServerStream
}

func (x *querierSeriesServer) Send(m *SeriesBatch) error {
	return x.ServerStream.SendMsg(m)
}

func _Querier_Next_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NextRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuerierServer).Next(m, &querierNextServer{stream})
}

type Querier_NextServer interface {
	Send(*StepVectorBatch) error
	grpc.ServerStream
}

type querierNextServer struct {
	grpc.ServerStream
}

func (x *querierNextServer) Send(m *StepVectorBatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Querier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "querierpb.Querier",
	HandlerType: (*QuerierServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Series",
			Handler:       _Querier_Series_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Next",
			Handler:       _Querier_Next_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/engine/distributed_execution/querierpb/querier.proto",
}

func (m *SeriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeriesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Batchsize != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.Batchsize))
		i--
		dAtA[i] = 0x18
	}
	if m.FragmentID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.FragmentID))
		i--
		dAtA[i] = 0x10
	}
	if m.QueryID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.QueryID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NextRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Batchsize != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.Batchsize))
		i--
		dAtA[i] = 0x18
	}
	if m.FragmentID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.FragmentID))
		i--
		dAtA[i] = 0x10
	}
	if m.QueryID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.QueryID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SeriesBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeriesBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OneSeries) > 0 {
		for iNdEx := len(m.OneSeries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OneSeries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OneSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OneSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StepVectorBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepVectorBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepVectorBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StepVectors) > 0 {
		for iNdEx := len(m.StepVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StepVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Histograms) > 0 {
		for iNdEx := len(m.Histograms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Histograms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Histogram_IDs) > 0 {
		dAtA2 := make([]byte, len(m.Histogram_IDs)*10)
		var j1 int
		for _, num := range m.Histogram_IDs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintQuerier(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			f3 := math.Float64bits(float64(m.Samples[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f3))
		}
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.Samples)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sample_IDs) > 0 {
		dAtA5 := make([]byte, len(m.Sample_IDs)*10)
		var j4 int
		for _, num := range m.Sample_IDs {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintQuerier(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x12
	}
	if m.T != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.T))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Label) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Histogram) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Histogram) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TimestampMs != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.TimestampMs))
		i--
		dAtA[i] = 0x78
	}
	if m.ResetHint != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.ResetHint))
		i--
		dAtA[i] = 0x70
	}
	if len(m.PositiveCounts) > 0 {
		for iNdEx := len(m.PositiveCounts) - 1; iNdEx >= 0; iNdEx-- {
			f6 := math.Float64bits(float64(m.PositiveCounts[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f6))
		}
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.PositiveCounts)*8))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.PositiveDeltas) > 0 {
		var j7 int
		dAtA9 := make([]byte, len(m.PositiveDeltas)*10)
		for _, num := range m.PositiveDeltas {
			x8 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x8 >= 1<<7 {
				dAtA9[j7] = uint8(uint64(x8)&0x7f | 0x80)
				j7++
				x8 >>= 7
			}
			dAtA9[j7] = uint8(x8)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA9[:j7])
		i = encodeVarintQuerier(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x62
	}
	if len(m.PositiveSpans) > 0 {
		for iNdEx := len(m.PositiveSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PositiveSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.NegativeCounts) > 0 {
		for iNdEx := len(m.NegativeCounts) - 1; iNdEx >= 0; iNdEx-- {
			f10 := math.Float64bits(float64(m.NegativeCounts[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f10))
		}
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.NegativeCounts)*8))
		i--
		dAtA[i] = 0x52
	}
	if len(m.NegativeDeltas) > 0 {
		var j11 int
		dAtA13 := make([]byte, len(m.NegativeDeltas)*10)
		for _, num := range m.NegativeDeltas {
			x12 := (uint64(num) << 1) ^ uint64((num >> 63))
			for x12 >= 1<<7 {
				dAtA13[j11] = uint8(uint64(x12)&0x7f | 0x80)
				j11++
				x12 >>= 7
			}
			dAtA13[j11] = uint8(x12)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA13[:j11])
		i = encodeVarintQuerier(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.NegativeSpans) > 0 {
		for iNdEx := len(m.NegativeSpans) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NegativeSpans[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ZeroCount != nil {
		{
			size := m.ZeroCount.Size()
			i -= size
			if _, err := m.ZeroCount.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.ZeroThreshold != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ZeroThreshold))))
		i--
		dAtA[i] = 0x29
	}
	if m.Schema != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64((uint32(m.Schema)<<1)^uint32((m.Schema>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.Sum != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Sum))))
		i--
		dAtA[i] = 0x19
	}
	if m.Count != nil {
		{
			size := m.Count.Size()
			i -= size
			if _, err := m.Count.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Histogram_CountInt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram_CountInt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintQuerier(dAtA, i, uint64(m.CountInt))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *Histogram_CountFloat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram_CountFloat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CountFloat))))
	i--
	dAtA[i] = 0x11
	return len(dAtA) - i, nil
}
func (m *Histogram_ZeroCountInt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram_ZeroCountInt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintQuerier(dAtA, i, uint64(m.ZeroCountInt))
	i--
	dAtA[i] = 0x30
	return len(dAtA) - i, nil
}
func (m *Histogram_ZeroCountFloat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Histogram_ZeroCountFloat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ZeroCountFloat))))
	i--
	dAtA[i] = 0x39
	return len(dAtA) - i, nil
}
func (m *BucketSpan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BucketSpan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BucketSpan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Length != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64((uint32(m.Offset)<<1)^uint32((m.Offset>>31))))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuerier(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuerier(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SeriesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryID != 0 {
		n += 1 + sovQuerier(uint64(m.QueryID))
	}
	if m.FragmentID != 0 {
		n += 1 + sovQuerier(uint64(m.FragmentID))
	}
	if m.Batchsize != 0 {
		n += 1 + sovQuerier(uint64(m.Batchsize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NextRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryID != 0 {
		n += 1 + sovQuerier(uint64(m.QueryID))
	}
	if m.FragmentID != 0 {
		n += 1 + sovQuerier(uint64(m.FragmentID))
	}
	if m.Batchsize != 0 {
		n += 1 + sovQuerier(uint64(m.Batchsize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SeriesBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OneSeries) > 0 {
		for _, e := range m.OneSeries {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OneSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepVectorBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StepVectors) > 0 {
		for _, e := range m.StepVectors {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StepVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != 0 {
		n += 1 + sovQuerier(uint64(m.T))
	}
	if len(m.Sample_IDs) > 0 {
		l = 0
		for _, e := range m.Sample_IDs {
			l += sovQuerier(uint64(e))
		}
		n += 1 + sovQuerier(uint64(l)) + l
	}
	if len(m.Samples) > 0 {
		n += 1 + sovQuerier(uint64(len(m.Samples)*8)) + len(m.Samples)*8
	}
	if len(m.Histogram_IDs) > 0 {
		l = 0
		for _, e := range m.Histogram_IDs {
			l += sovQuerier(uint64(e))
		}
		n += 1 + sovQuerier(uint64(l)) + l
	}
	if len(m.Histograms) > 0 {
		for _, e := range m.Histograms {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Label) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuerier(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovQuerier(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Histogram) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != nil {
		n += m.Count.Size()
	}
	if m.Sum != 0 {
		n += 9
	}
	if m.Schema != 0 {
		n += 1 + sozQuerier(uint64(m.Schema))
	}
	if m.ZeroThreshold != 0 {
		n += 9
	}
	if m.ZeroCount != nil {
		n += m.ZeroCount.Size()
	}
	if len(m.NegativeSpans) > 0 {
		for _, e := range m.NegativeSpans {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	if len(m.NegativeDeltas) > 0 {
		l = 0
		for _, e := range m.NegativeDeltas {
			l += sozQuerier(uint64(e))
		}
		n += 1 + sovQuerier(uint64(l)) + l
	}
	if len(m.NegativeCounts) > 0 {
		n += 1 + sovQuerier(uint64(len(m.NegativeCounts)*8)) + len(m.NegativeCounts)*8
	}
	if len(m.PositiveSpans) > 0 {
		for _, e := range m.PositiveSpans {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	if len(m.PositiveDeltas) > 0 {
		l = 0
		for _, e := range m.PositiveDeltas {
			l += sozQuerier(uint64(e))
		}
		n += 1 + sovQuerier(uint64(l)) + l
	}
	if len(m.PositiveCounts) > 0 {
		n += 1 + sovQuerier(uint64(len(m.PositiveCounts)*8)) + len(m.PositiveCounts)*8
	}
	if m.ResetHint != 0 {
		n += 1 + sovQuerier(uint64(m.ResetHint))
	}
	if m.TimestampMs != 0 {
		n += 1 + sovQuerier(uint64(m.TimestampMs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Histogram_CountInt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovQuerier(uint64(m.CountInt))
	return n
}
func (m *Histogram_CountFloat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *Histogram_ZeroCountInt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovQuerier(uint64(m.ZeroCountInt))
	return n
}
func (m *Histogram_ZeroCountFloat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *BucketSpan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sozQuerier(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovQuerier(uint64(m.Length))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovQuerier(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuerier(x uint64) (n int) {
	return sovQuerier(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SeriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			m.QueryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentID", wireType)
			}
			m.FragmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batchsize", wireType)
			}
			m.Batchsize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Batchsize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			m.QueryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentID", wireType)
			}
			m.FragmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batchsize", wireType)
			}
			m.Batchsize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Batchsize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneSeries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneSeries = append(m.OneSeries, &OneSeries{})
			if err := m.OneSeries[len(m.OneSeries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepVectorBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepVectorBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepVectorBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepVectors = append(m.StepVectors, &StepVector{})
			if err := m.StepVectors[len(m.StepVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			m.T = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sample_IDs = append(m.Sample_IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Sample_IDs) == 0 {
					m.Sample_IDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuerier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sample_IDs = append(m.Sample_IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample_IDs", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Samples = append(m.Samples, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Samples) == 0 {
					m.Samples = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Samples = append(m.Samples, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Histogram_IDs = append(m.Histogram_IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Histogram_IDs) == 0 {
					m.Histogram_IDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuerier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Histogram_IDs = append(m.Histogram_IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram_IDs", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histograms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Histograms = append(m.Histograms, Histogram{})
			if err := m.Histograms[len(m.Histograms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Histogram) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Histogram: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Histogram: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountInt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Count = &Histogram_CountInt{v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountFloat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Count = &Histogram_CountFloat{float64(math.Float64frombits(v))}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Sum = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Schema = v
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroThreshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ZeroThreshold = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroCountInt", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ZeroCount = &Histogram_ZeroCountInt{v}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroCountFloat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ZeroCount = &Histogram_ZeroCountFloat{float64(math.Float64frombits(v))}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NegativeSpans = append(m.NegativeSpans, BucketSpan{})
			if err := m.NegativeSpans[len(m.NegativeSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.NegativeDeltas = append(m.NegativeDeltas, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NegativeDeltas) == 0 {
					m.NegativeDeltas = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuerier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.NegativeDeltas = append(m.NegativeDeltas, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeDeltas", wireType)
			}
		case 10:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.NegativeCounts = append(m.NegativeCounts, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.NegativeCounts) == 0 {
					m.NegativeCounts = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.NegativeCounts = append(m.NegativeCounts, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeCounts", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveSpans", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PositiveSpans = append(m.PositiveSpans, BucketSpan{})
			if err := m.PositiveSpans[len(m.PositiveSpans)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
				m.PositiveDeltas = append(m.PositiveDeltas, int64(v))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PositiveDeltas) == 0 {
					m.PositiveDeltas = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuerier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
					m.PositiveDeltas = append(m.PositiveDeltas, int64(v))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveDeltas", wireType)
			}
		case 13:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.PositiveCounts = append(m.PositiveCounts, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.PositiveCounts) == 0 {
					m.PositiveCounts = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.PositiveCounts = append(m.PositiveCounts, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveCounts", wireType)
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResetHint", wireType)
			}
			m.ResetHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResetHint |= Histogram_ResetHint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMs", wireType)
			}
			m.TimestampMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BucketSpan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BucketSpan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BucketSpan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Offset = v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuerier(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuerier
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuerier
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuerier
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuerier        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuerier          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuerier = fmt.Errorf("proto: unexpected end of group")
)
