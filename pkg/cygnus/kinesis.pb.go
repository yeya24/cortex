// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kinesis.proto

package cygnus

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// =================================
type FileFormat int32

const (
	FileFormatUnknown FileFormat = 0
	FileFormatParquet FileFormat = 1
)

var FileFormat_name = map[int32]string{
	0: "FileFormatUnknown",
	1: "FileFormatParquet",
}

var FileFormat_value = map[string]int32{
	"FileFormatUnknown": 0,
	"FileFormatParquet": 1,
}

func (FileFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{0}
}

type DataFileEntry_Type int32

const (
	DataFileEntryTypeUnknown  DataFileEntry_Type = 0
	DataFileEntryTypeStandard DataFileEntry_Type = 1
	DataFileEntryTypeLarge    DataFileEntry_Type = 2
)

var DataFileEntry_Type_name = map[int32]string{
	0: "DataFileEntryTypeUnknown",
	1: "DataFileEntryTypeStandard",
	2: "DataFileEntryTypeLarge",
}

var DataFileEntry_Type_value = map[string]int32{
	"DataFileEntryTypeUnknown":  0,
	"DataFileEntryTypeStandard": 1,
	"DataFileEntryTypeLarge":    2,
}

func (DataFileEntry_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{1, 0}
}

type StandardDataFileEntry_Version int32

const (
	StandardDataFileEntryVersionUnknown StandardDataFileEntry_Version = 0
	StandardDataFileEntryVersionV1      StandardDataFileEntry_Version = 1
)

var StandardDataFileEntry_Version_name = map[int32]string{
	0: "StandardDataFileEntryVersionUnknown",
	1: "StandardDataFileEntryVersionV1",
}

var StandardDataFileEntry_Version_value = map[string]int32{
	"StandardDataFileEntryVersionUnknown": 0,
	"StandardDataFileEntryVersionV1":      1,
}

func (StandardDataFileEntry_Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{2, 0}
}

type MetadataCommitRecord_Type int32

const (
	MetadataCommitRecordTypeUnknown             MetadataCommitRecord_Type = 0
	MetadataCommitRecordTypeIcebergCommitRecord MetadataCommitRecord_Type = 1
)

var MetadataCommitRecord_Type_name = map[int32]string{
	0: "MetadataCommitRecordTypeUnknown",
	1: "MetadataCommitRecordTypeIcebergCommitRecord",
}

var MetadataCommitRecord_Type_value = map[string]int32{
	"MetadataCommitRecordTypeUnknown":             0,
	"MetadataCommitRecordTypeIcebergCommitRecord": 1,
}

func (MetadataCommitRecord_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{6, 0}
}

type IcebergCommitRecord_Version int32

const (
	IcebergCommitRecordVersionUnknown IcebergCommitRecord_Version = 0
	IcebergCommitRecordVersionV1      IcebergCommitRecord_Version = 1
)

var IcebergCommitRecord_Version_name = map[int32]string{
	0: "IcebergCommitRecordVersionUnknown",
	1: "IcebergCommitRecordVersionV1",
}

var IcebergCommitRecord_Version_value = map[string]int32{
	"IcebergCommitRecordVersionUnknown": 0,
	"IcebergCommitRecordVersionV1":      1,
}

func (IcebergCommitRecord_Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{7, 0}
}

type AddedDataFiles_Type int32

const (
	AddedDataFilesTypeUnknown  AddedDataFiles_Type = 0
	AddedDataFilesTypeEmbedded AddedDataFiles_Type = 1
	AddedDataFilesTypeLarge    AddedDataFiles_Type = 2
)

var AddedDataFiles_Type_name = map[int32]string{
	0: "AddedDataFilesTypeUnknown",
	1: "AddedDataFilesTypeEmbedded",
	2: "AddedDataFilesTypeLarge",
}

var AddedDataFiles_Type_value = map[string]int32{
	"AddedDataFilesTypeUnknown":  0,
	"AddedDataFilesTypeEmbedded": 1,
	"AddedDataFilesTypeLarge":    2,
}

func (AddedDataFiles_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{13, 0}
}

// =================================
type DataFileEntryRecord struct {
	DataFileEntry *DataFileEntry `protobuf:"bytes,1,opt,name=dataFileEntry,proto3" json:"dataFileEntry,omitempty"`
	DataFileInfo  *DataFileInfo  `protobuf:"bytes,2,opt,name=dataFileInfo,proto3" json:"dataFileInfo,omitempty"`
}

func (m *DataFileEntryRecord) Reset()      { *m = DataFileEntryRecord{} }
func (*DataFileEntryRecord) ProtoMessage() {}
func (*DataFileEntryRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{0}
}
func (m *DataFileEntryRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileEntryRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileEntryRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileEntryRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileEntryRecord.Merge(m, src)
}
func (m *DataFileEntryRecord) XXX_Size() int {
	return m.Size()
}
func (m *DataFileEntryRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileEntryRecord.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileEntryRecord proto.InternalMessageInfo

func (m *DataFileEntryRecord) GetDataFileEntry() *DataFileEntry {
	if m != nil {
		return m.DataFileEntry
	}
	return nil
}

func (m *DataFileEntryRecord) GetDataFileInfo() *DataFileInfo {
	if m != nil {
		return m.DataFileInfo
	}
	return nil
}

type DataFileEntry struct {
	Type                  DataFileEntry_Type     `protobuf:"varint,1,opt,name=type,proto3,enum=cygnus.DataFileEntry_Type" json:"type,omitempty"`
	StandardDataFileEntry *StandardDataFileEntry `protobuf:"bytes,2,opt,name=standardDataFileEntry,proto3" json:"standardDataFileEntry,omitempty"`
	LargeDataFileEntry    *LargeDataFileEntry    `protobuf:"bytes,3,opt,name=largeDataFileEntry,proto3" json:"largeDataFileEntry,omitempty"`
}

func (m *DataFileEntry) Reset()      { *m = DataFileEntry{} }
func (*DataFileEntry) ProtoMessage() {}
func (*DataFileEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{1}
}
func (m *DataFileEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileEntry.Merge(m, src)
}
func (m *DataFileEntry) XXX_Size() int {
	return m.Size()
}
func (m *DataFileEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileEntry.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileEntry proto.InternalMessageInfo

func (m *DataFileEntry) GetType() DataFileEntry_Type {
	if m != nil {
		return m.Type
	}
	return DataFileEntryTypeUnknown
}

func (m *DataFileEntry) GetStandardDataFileEntry() *StandardDataFileEntry {
	if m != nil {
		return m.StandardDataFileEntry
	}
	return nil
}

func (m *DataFileEntry) GetLargeDataFileEntry() *LargeDataFileEntry {
	if m != nil {
		return m.LargeDataFileEntry
	}
	return nil
}

type StandardDataFileEntry struct {
	Version    StandardDataFileEntry_Version `protobuf:"varint,1,opt,name=version,proto3,enum=cygnus.StandardDataFileEntry_Version" json:"version,omitempty"`
	DataFileV1 *DataFileV1                   `protobuf:"bytes,2,opt,name=dataFileV1,proto3" json:"dataFileV1,omitempty"`
}

func (m *StandardDataFileEntry) Reset()      { *m = StandardDataFileEntry{} }
func (*StandardDataFileEntry) ProtoMessage() {}
func (*StandardDataFileEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{2}
}
func (m *StandardDataFileEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StandardDataFileEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StandardDataFileEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StandardDataFileEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StandardDataFileEntry.Merge(m, src)
}
func (m *StandardDataFileEntry) XXX_Size() int {
	return m.Size()
}
func (m *StandardDataFileEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_StandardDataFileEntry.DiscardUnknown(m)
}

var xxx_messageInfo_StandardDataFileEntry proto.InternalMessageInfo

func (m *StandardDataFileEntry) GetVersion() StandardDataFileEntry_Version {
	if m != nil {
		return m.Version
	}
	return StandardDataFileEntryVersionUnknown
}

func (m *StandardDataFileEntry) GetDataFileV1() *DataFileV1 {
	if m != nil {
		return m.DataFileV1
	}
	return nil
}

type DataFileV1 struct {
	FilePath         string             `protobuf:"bytes,1,opt,name=filePath,proto3" json:"filePath,omitempty"`
	FileFormat       FileFormat         `protobuf:"varint,2,opt,name=fileFormat,proto3,enum=cygnus.FileFormat" json:"fileFormat,omitempty"`
	RecordCount      uint64             `protobuf:"varint,3,opt,name=recordCount,proto3" json:"recordCount,omitempty"`
	FileSizeInBytes  uint64             `protobuf:"varint,4,opt,name=fileSizeInBytes,proto3" json:"fileSizeInBytes,omitempty"`
	ColumnSizes      map[int32]uint64   `protobuf:"bytes,5,rep,name=columnSizes,proto3" json:"columnSizes,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ValueCounts      map[int32]uint64   `protobuf:"bytes,6,rep,name=valueCounts,proto3" json:"valueCounts,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	NullValueCounts  map[int32]uint64   `protobuf:"bytes,7,rep,name=nullValueCounts,proto3" json:"nullValueCounts,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	NanValueCounts   map[int32]uint64   `protobuf:"bytes,8,rep,name=nanValueCounts,proto3" json:"nanValueCounts,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	LowerBounds      map[int32][]byte   `protobuf:"bytes,9,rep,name=lowerBounds,proto3" json:"lowerBounds,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	UpperBounds      map[int32][]byte   `protobuf:"bytes,10,rep,name=upperBounds,proto3" json:"upperBounds,omitempty" protobuf_key:"fixed32,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	IndexedFields    []string           `protobuf:"bytes,11,rep,name=indexedFields,proto3" json:"indexedFields,omitempty"`
	SchemaReferences []*SchemaReference `protobuf:"bytes,12,rep,name=schemaReferences,proto3" json:"schemaReferences,omitempty"`
}

func (m *DataFileV1) Reset()      { *m = DataFileV1{} }
func (*DataFileV1) ProtoMessage() {}
func (*DataFileV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{3}
}
func (m *DataFileV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileV1.Merge(m, src)
}
func (m *DataFileV1) XXX_Size() int {
	return m.Size()
}
func (m *DataFileV1) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileV1.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileV1 proto.InternalMessageInfo

func (m *DataFileV1) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *DataFileV1) GetFileFormat() FileFormat {
	if m != nil {
		return m.FileFormat
	}
	return FileFormatUnknown
}

func (m *DataFileV1) GetRecordCount() uint64 {
	if m != nil {
		return m.RecordCount
	}
	return 0
}

func (m *DataFileV1) GetFileSizeInBytes() uint64 {
	if m != nil {
		return m.FileSizeInBytes
	}
	return 0
}

func (m *DataFileV1) GetColumnSizes() map[int32]uint64 {
	if m != nil {
		return m.ColumnSizes
	}
	return nil
}

func (m *DataFileV1) GetValueCounts() map[int32]uint64 {
	if m != nil {
		return m.ValueCounts
	}
	return nil
}

func (m *DataFileV1) GetNullValueCounts() map[int32]uint64 {
	if m != nil {
		return m.NullValueCounts
	}
	return nil
}

func (m *DataFileV1) GetNanValueCounts() map[int32]uint64 {
	if m != nil {
		return m.NanValueCounts
	}
	return nil
}

func (m *DataFileV1) GetLowerBounds() map[int32][]byte {
	if m != nil {
		return m.LowerBounds
	}
	return nil
}

func (m *DataFileV1) GetUpperBounds() map[int32][]byte {
	if m != nil {
		return m.UpperBounds
	}
	return nil
}

func (m *DataFileV1) GetIndexedFields() []string {
	if m != nil {
		return m.IndexedFields
	}
	return nil
}

func (m *DataFileV1) GetSchemaReferences() []*SchemaReference {
	if m != nil {
		return m.SchemaReferences
	}
	return nil
}

type LargeDataFileEntry struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *LargeDataFileEntry) Reset()      { *m = LargeDataFileEntry{} }
func (*LargeDataFileEntry) ProtoMessage() {}
func (*LargeDataFileEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{4}
}
func (m *LargeDataFileEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LargeDataFileEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LargeDataFileEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LargeDataFileEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LargeDataFileEntry.Merge(m, src)
}
func (m *LargeDataFileEntry) XXX_Size() int {
	return m.Size()
}
func (m *LargeDataFileEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LargeDataFileEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LargeDataFileEntry proto.InternalMessageInfo

func (m *LargeDataFileEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DataFileInfo struct {
	FilePath     string `protobuf:"bytes,1,opt,name=filePath,proto3" json:"filePath,omitempty"`
	CreationTime uint64 `protobuf:"varint,2,opt,name=creationTime,proto3" json:"creationTime,omitempty"`
	AccountId    string `protobuf:"bytes,3,opt,name=accountId,proto3" json:"accountId,omitempty"`
}

func (m *DataFileInfo) Reset()      { *m = DataFileInfo{} }
func (*DataFileInfo) ProtoMessage() {}
func (*DataFileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{5}
}
func (m *DataFileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataFileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataFileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataFileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataFileInfo.Merge(m, src)
}
func (m *DataFileInfo) XXX_Size() int {
	return m.Size()
}
func (m *DataFileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DataFileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DataFileInfo proto.InternalMessageInfo

func (m *DataFileInfo) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *DataFileInfo) GetCreationTime() uint64 {
	if m != nil {
		return m.CreationTime
	}
	return 0
}

func (m *DataFileInfo) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

// =================================
type MetadataCommitRecord struct {
	Type                MetadataCommitRecord_Type `protobuf:"varint,1,opt,name=type,proto3,enum=cygnus.MetadataCommitRecord_Type" json:"type,omitempty"`
	IcebergCommitRecord *IcebergCommitRecord      `protobuf:"bytes,2,opt,name=icebergCommitRecord,proto3" json:"icebergCommitRecord,omitempty"`
}

func (m *MetadataCommitRecord) Reset()      { *m = MetadataCommitRecord{} }
func (*MetadataCommitRecord) ProtoMessage() {}
func (*MetadataCommitRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{6}
}
func (m *MetadataCommitRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataCommitRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataCommitRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataCommitRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataCommitRecord.Merge(m, src)
}
func (m *MetadataCommitRecord) XXX_Size() int {
	return m.Size()
}
func (m *MetadataCommitRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataCommitRecord.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataCommitRecord proto.InternalMessageInfo

func (m *MetadataCommitRecord) GetType() MetadataCommitRecord_Type {
	if m != nil {
		return m.Type
	}
	return MetadataCommitRecordTypeUnknown
}

func (m *MetadataCommitRecord) GetIcebergCommitRecord() *IcebergCommitRecord {
	if m != nil {
		return m.IcebergCommitRecord
	}
	return nil
}

type IcebergCommitRecord struct {
	Version               IcebergCommitRecord_Version `protobuf:"varint,1,opt,name=version,proto3,enum=cygnus.IcebergCommitRecord_Version" json:"version,omitempty"`
	IcebergCommitRecordV1 *IcebergCommitRecordV1      `protobuf:"bytes,2,opt,name=icebergCommitRecordV1,proto3" json:"icebergCommitRecordV1,omitempty"`
}

func (m *IcebergCommitRecord) Reset()      { *m = IcebergCommitRecord{} }
func (*IcebergCommitRecord) ProtoMessage() {}
func (*IcebergCommitRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{7}
}
func (m *IcebergCommitRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IcebergCommitRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IcebergCommitRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IcebergCommitRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IcebergCommitRecord.Merge(m, src)
}
func (m *IcebergCommitRecord) XXX_Size() int {
	return m.Size()
}
func (m *IcebergCommitRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_IcebergCommitRecord.DiscardUnknown(m)
}

var xxx_messageInfo_IcebergCommitRecord proto.InternalMessageInfo

func (m *IcebergCommitRecord) GetVersion() IcebergCommitRecord_Version {
	if m != nil {
		return m.Version
	}
	return IcebergCommitRecordVersionUnknown
}

func (m *IcebergCommitRecord) GetIcebergCommitRecordV1() *IcebergCommitRecordV1 {
	if m != nil {
		return m.IcebergCommitRecordV1
	}
	return nil
}

type IcebergCommitRecordV1 struct {
	CommitInfo     *IcebergCommitInfo `protobuf:"bytes,1,opt,name=commitInfo,proto3" json:"commitInfo,omitempty"`
	FieldIndexInfo *FieldIndexInfo    `protobuf:"bytes,2,opt,name=fieldIndexInfo,proto3" json:"fieldIndexInfo,omitempty"`
}

func (m *IcebergCommitRecordV1) Reset()      { *m = IcebergCommitRecordV1{} }
func (*IcebergCommitRecordV1) ProtoMessage() {}
func (*IcebergCommitRecordV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{8}
}
func (m *IcebergCommitRecordV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IcebergCommitRecordV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IcebergCommitRecordV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IcebergCommitRecordV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IcebergCommitRecordV1.Merge(m, src)
}
func (m *IcebergCommitRecordV1) XXX_Size() int {
	return m.Size()
}
func (m *IcebergCommitRecordV1) XXX_DiscardUnknown() {
	xxx_messageInfo_IcebergCommitRecordV1.DiscardUnknown(m)
}

var xxx_messageInfo_IcebergCommitRecordV1 proto.InternalMessageInfo

func (m *IcebergCommitRecordV1) GetCommitInfo() *IcebergCommitInfo {
	if m != nil {
		return m.CommitInfo
	}
	return nil
}

func (m *IcebergCommitRecordV1) GetFieldIndexInfo() *FieldIndexInfo {
	if m != nil {
		return m.FieldIndexInfo
	}
	return nil
}

type IcebergCommitInfo struct {
	ResourceInfo       *ResourceInfo       `protobuf:"bytes,1,opt,name=resourceInfo,proto3" json:"resourceInfo,omitempty"`
	ManifestFileUpdate *ManifestFileUpdate `protobuf:"bytes,2,opt,name=manifestFileUpdate,proto3" json:"manifestFileUpdate,omitempty"`
	CommitTimestamp    uint64              `protobuf:"varint,3,opt,name=commitTimestamp,proto3" json:"commitTimestamp,omitempty"`
}

func (m *IcebergCommitInfo) Reset()      { *m = IcebergCommitInfo{} }
func (*IcebergCommitInfo) ProtoMessage() {}
func (*IcebergCommitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{9}
}
func (m *IcebergCommitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IcebergCommitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IcebergCommitInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IcebergCommitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IcebergCommitInfo.Merge(m, src)
}
func (m *IcebergCommitInfo) XXX_Size() int {
	return m.Size()
}
func (m *IcebergCommitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IcebergCommitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IcebergCommitInfo proto.InternalMessageInfo

func (m *IcebergCommitInfo) GetResourceInfo() *ResourceInfo {
	if m != nil {
		return m.ResourceInfo
	}
	return nil
}

func (m *IcebergCommitInfo) GetManifestFileUpdate() *ManifestFileUpdate {
	if m != nil {
		return m.ManifestFileUpdate
	}
	return nil
}

func (m *IcebergCommitInfo) GetCommitTimestamp() uint64 {
	if m != nil {
		return m.CommitTimestamp
	}
	return 0
}

type ResourceInfo struct {
	AccountId          string `protobuf:"bytes,1,opt,name=accountId,proto3" json:"accountId,omitempty"`
	LogGroupName       string `protobuf:"bytes,2,opt,name=logGroupName,proto3" json:"logGroupName,omitempty"`
	LogGroupInternalId string `protobuf:"bytes,3,opt,name=logGroupInternalId,proto3" json:"logGroupInternalId,omitempty"`
	SchemaId           string `protobuf:"bytes,4,opt,name=schemaId,proto3" json:"schemaId,omitempty"`
}

func (m *ResourceInfo) Reset()      { *m = ResourceInfo{} }
func (*ResourceInfo) ProtoMessage() {}
func (*ResourceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{10}
}
func (m *ResourceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceInfo.Merge(m, src)
}
func (m *ResourceInfo) XXX_Size() int {
	return m.Size()
}
func (m *ResourceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceInfo proto.InternalMessageInfo

func (m *ResourceInfo) GetAccountId() string {
	if m != nil {
		return m.AccountId
	}
	return ""
}

func (m *ResourceInfo) GetLogGroupName() string {
	if m != nil {
		return m.LogGroupName
	}
	return ""
}

func (m *ResourceInfo) GetLogGroupInternalId() string {
	if m != nil {
		return m.LogGroupInternalId
	}
	return ""
}

func (m *ResourceInfo) GetSchemaId() string {
	if m != nil {
		return m.SchemaId
	}
	return ""
}

type FieldIndexInfo struct {
	IndexedFields []string `protobuf:"bytes,1,rep,name=indexedFields,proto3" json:"indexedFields,omitempty"`
}

func (m *FieldIndexInfo) Reset()      { *m = FieldIndexInfo{} }
func (*FieldIndexInfo) ProtoMessage() {}
func (*FieldIndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{11}
}
func (m *FieldIndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldIndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldIndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldIndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldIndexInfo.Merge(m, src)
}
func (m *FieldIndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *FieldIndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldIndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FieldIndexInfo proto.InternalMessageInfo

func (m *FieldIndexInfo) GetIndexedFields() []string {
	if m != nil {
		return m.IndexedFields
	}
	return nil
}

type ManifestFileUpdate struct {
	// The portion of the path following the base location e.g. /metadata/.../filename.avro
	PreviousManifestFilePathSuffix string          `protobuf:"bytes,1,opt,name=previousManifestFilePathSuffix,proto3" json:"previousManifestFilePathSuffix,omitempty"`
	NewManifestFilePathSuffix      string          `protobuf:"bytes,2,opt,name=newManifestFilePathSuffix,proto3" json:"newManifestFilePathSuffix,omitempty"`
	BaseLocation                   string          `protobuf:"bytes,3,opt,name=baseLocation,proto3" json:"baseLocation,omitempty"`
	AddedDataFiles                 *AddedDataFiles `protobuf:"bytes,4,opt,name=addedDataFiles,proto3" json:"addedDataFiles,omitempty"`
}

func (m *ManifestFileUpdate) Reset()      { *m = ManifestFileUpdate{} }
func (*ManifestFileUpdate) ProtoMessage() {}
func (*ManifestFileUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{12}
}
func (m *ManifestFileUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManifestFileUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManifestFileUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManifestFileUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManifestFileUpdate.Merge(m, src)
}
func (m *ManifestFileUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ManifestFileUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ManifestFileUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ManifestFileUpdate proto.InternalMessageInfo

func (m *ManifestFileUpdate) GetPreviousManifestFilePathSuffix() string {
	if m != nil {
		return m.PreviousManifestFilePathSuffix
	}
	return ""
}

func (m *ManifestFileUpdate) GetNewManifestFilePathSuffix() string {
	if m != nil {
		return m.NewManifestFilePathSuffix
	}
	return ""
}

func (m *ManifestFileUpdate) GetBaseLocation() string {
	if m != nil {
		return m.BaseLocation
	}
	return ""
}

func (m *ManifestFileUpdate) GetAddedDataFiles() *AddedDataFiles {
	if m != nil {
		return m.AddedDataFiles
	}
	return nil
}

type AddedDataFiles struct {
	Type                   AddedDataFiles_Type     `protobuf:"varint,1,opt,name=type,proto3,enum=cygnus.AddedDataFiles_Type" json:"type,omitempty"`
	EmbeddedAddedDataFiles *EmbeddedAddedDataFiles `protobuf:"bytes,2,opt,name=embeddedAddedDataFiles,proto3" json:"embeddedAddedDataFiles,omitempty"`
	LargeAddedDataFiles    *LargeAddedDataFiles    `protobuf:"bytes,3,opt,name=largeAddedDataFiles,proto3" json:"largeAddedDataFiles,omitempty"`
}

func (m *AddedDataFiles) Reset()      { *m = AddedDataFiles{} }
func (*AddedDataFiles) ProtoMessage() {}
func (*AddedDataFiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{13}
}
func (m *AddedDataFiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddedDataFiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddedDataFiles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddedDataFiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddedDataFiles.Merge(m, src)
}
func (m *AddedDataFiles) XXX_Size() int {
	return m.Size()
}
func (m *AddedDataFiles) XXX_DiscardUnknown() {
	xxx_messageInfo_AddedDataFiles.DiscardUnknown(m)
}

var xxx_messageInfo_AddedDataFiles proto.InternalMessageInfo

func (m *AddedDataFiles) GetType() AddedDataFiles_Type {
	if m != nil {
		return m.Type
	}
	return AddedDataFilesTypeUnknown
}

func (m *AddedDataFiles) GetEmbeddedAddedDataFiles() *EmbeddedAddedDataFiles {
	if m != nil {
		return m.EmbeddedAddedDataFiles
	}
	return nil
}

func (m *AddedDataFiles) GetLargeAddedDataFiles() *LargeAddedDataFiles {
	if m != nil {
		return m.LargeAddedDataFiles
	}
	return nil
}

type EmbeddedAddedDataFiles struct {
	AddedDataFiles []*AddedDataFile `protobuf:"bytes,1,rep,name=addedDataFiles,proto3" json:"addedDataFiles,omitempty"`
}

func (m *EmbeddedAddedDataFiles) Reset()      { *m = EmbeddedAddedDataFiles{} }
func (*EmbeddedAddedDataFiles) ProtoMessage() {}
func (*EmbeddedAddedDataFiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{14}
}
func (m *EmbeddedAddedDataFiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EmbeddedAddedDataFiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EmbeddedAddedDataFiles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EmbeddedAddedDataFiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EmbeddedAddedDataFiles.Merge(m, src)
}
func (m *EmbeddedAddedDataFiles) XXX_Size() int {
	return m.Size()
}
func (m *EmbeddedAddedDataFiles) XXX_DiscardUnknown() {
	xxx_messageInfo_EmbeddedAddedDataFiles.DiscardUnknown(m)
}

var xxx_messageInfo_EmbeddedAddedDataFiles proto.InternalMessageInfo

func (m *EmbeddedAddedDataFiles) GetAddedDataFiles() []*AddedDataFile {
	if m != nil {
		return m.AddedDataFiles
	}
	return nil
}

type LargeAddedDataFiles struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *LargeAddedDataFiles) Reset()      { *m = LargeAddedDataFiles{} }
func (*LargeAddedDataFiles) ProtoMessage() {}
func (*LargeAddedDataFiles) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{15}
}
func (m *LargeAddedDataFiles) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LargeAddedDataFiles) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LargeAddedDataFiles.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LargeAddedDataFiles) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LargeAddedDataFiles.Merge(m, src)
}
func (m *LargeAddedDataFiles) XXX_Size() int {
	return m.Size()
}
func (m *LargeAddedDataFiles) XXX_DiscardUnknown() {
	xxx_messageInfo_LargeAddedDataFiles.DiscardUnknown(m)
}

var xxx_messageInfo_LargeAddedDataFiles proto.InternalMessageInfo

func (m *LargeAddedDataFiles) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type AddedDataFile struct {
	// The portion of the path following the base location e.g. /data/.../filename.parquet
	DataFilePathSuffix   string     `protobuf:"bytes,1,opt,name=dataFilePathSuffix,proto3" json:"dataFilePathSuffix,omitempty"`
	ManifestFilePosition uint32     `protobuf:"varint,2,opt,name=manifestFilePosition,proto3" json:"manifestFilePosition,omitempty"`
	TimestampFrom        uint64     `protobuf:"varint,3,opt,name=timestampFrom,proto3" json:"timestampFrom,omitempty"`
	TimestampTo          uint64     `protobuf:"varint,4,opt,name=timestampTo,proto3" json:"timestampTo,omitempty"`
	RecordCount          uint64     `protobuf:"varint,5,opt,name=recordCount,proto3" json:"recordCount,omitempty"`
	UncompressedSize     uint64     `protobuf:"varint,6,opt,name=uncompressedSize,proto3" json:"uncompressedSize,omitempty"`
	CreationTime         uint64     `protobuf:"varint,7,opt,name=creationTime,proto3" json:"creationTime,omitempty"`
	FileFormat           FileFormat `protobuf:"varint,8,opt,name=fileFormat,proto3,enum=cygnus.FileFormat" json:"fileFormat,omitempty"`
}

func (m *AddedDataFile) Reset()      { *m = AddedDataFile{} }
func (*AddedDataFile) ProtoMessage() {}
func (*AddedDataFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{16}
}
func (m *AddedDataFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddedDataFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddedDataFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddedDataFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddedDataFile.Merge(m, src)
}
func (m *AddedDataFile) XXX_Size() int {
	return m.Size()
}
func (m *AddedDataFile) XXX_DiscardUnknown() {
	xxx_messageInfo_AddedDataFile.DiscardUnknown(m)
}

var xxx_messageInfo_AddedDataFile proto.InternalMessageInfo

func (m *AddedDataFile) GetDataFilePathSuffix() string {
	if m != nil {
		return m.DataFilePathSuffix
	}
	return ""
}

func (m *AddedDataFile) GetManifestFilePosition() uint32 {
	if m != nil {
		return m.ManifestFilePosition
	}
	return 0
}

func (m *AddedDataFile) GetTimestampFrom() uint64 {
	if m != nil {
		return m.TimestampFrom
	}
	return 0
}

func (m *AddedDataFile) GetTimestampTo() uint64 {
	if m != nil {
		return m.TimestampTo
	}
	return 0
}

func (m *AddedDataFile) GetRecordCount() uint64 {
	if m != nil {
		return m.RecordCount
	}
	return 0
}

func (m *AddedDataFile) GetUncompressedSize() uint64 {
	if m != nil {
		return m.UncompressedSize
	}
	return 0
}

func (m *AddedDataFile) GetCreationTime() uint64 {
	if m != nil {
		return m.CreationTime
	}
	return 0
}

func (m *AddedDataFile) GetFileFormat() FileFormat {
	if m != nil {
		return m.FileFormat
	}
	return FileFormatUnknown
}

type SchemaReference struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Hash string `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *SchemaReference) Reset()      { *m = SchemaReference{} }
func (*SchemaReference) ProtoMessage() {}
func (*SchemaReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ca670e82d9f05f1, []int{17}
}
func (m *SchemaReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaReference.Merge(m, src)
}
func (m *SchemaReference) XXX_Size() int {
	return m.Size()
}
func (m *SchemaReference) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaReference.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaReference proto.InternalMessageInfo

func (m *SchemaReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaReference) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func init() {
	proto.RegisterEnum("cygnus.FileFormat", FileFormat_name, FileFormat_value)
	proto.RegisterEnum("cygnus.DataFileEntry_Type", DataFileEntry_Type_name, DataFileEntry_Type_value)
	proto.RegisterEnum("cygnus.StandardDataFileEntry_Version", StandardDataFileEntry_Version_name, StandardDataFileEntry_Version_value)
	proto.RegisterEnum("cygnus.MetadataCommitRecord_Type", MetadataCommitRecord_Type_name, MetadataCommitRecord_Type_value)
	proto.RegisterEnum("cygnus.IcebergCommitRecord_Version", IcebergCommitRecord_Version_name, IcebergCommitRecord_Version_value)
	proto.RegisterEnum("cygnus.AddedDataFiles_Type", AddedDataFiles_Type_name, AddedDataFiles_Type_value)
	proto.RegisterType((*DataFileEntryRecord)(nil), "cygnus.DataFileEntryRecord")
	proto.RegisterType((*DataFileEntry)(nil), "cygnus.DataFileEntry")
	proto.RegisterType((*StandardDataFileEntry)(nil), "cygnus.StandardDataFileEntry")
	proto.RegisterType((*DataFileV1)(nil), "cygnus.DataFileV1")
	proto.RegisterMapType((map[int32]uint64)(nil), "cygnus.DataFileV1.ColumnSizesEntry")
	proto.RegisterMapType((map[int32][]byte)(nil), "cygnus.DataFileV1.LowerBoundsEntry")
	proto.RegisterMapType((map[int32]uint64)(nil), "cygnus.DataFileV1.NanValueCountsEntry")
	proto.RegisterMapType((map[int32]uint64)(nil), "cygnus.DataFileV1.NullValueCountsEntry")
	proto.RegisterMapType((map[int32][]byte)(nil), "cygnus.DataFileV1.UpperBoundsEntry")
	proto.RegisterMapType((map[int32]uint64)(nil), "cygnus.DataFileV1.ValueCountsEntry")
	proto.RegisterType((*LargeDataFileEntry)(nil), "cygnus.LargeDataFileEntry")
	proto.RegisterType((*DataFileInfo)(nil), "cygnus.DataFileInfo")
	proto.RegisterType((*MetadataCommitRecord)(nil), "cygnus.MetadataCommitRecord")
	proto.RegisterType((*IcebergCommitRecord)(nil), "cygnus.IcebergCommitRecord")
	proto.RegisterType((*IcebergCommitRecordV1)(nil), "cygnus.IcebergCommitRecordV1")
	proto.RegisterType((*IcebergCommitInfo)(nil), "cygnus.IcebergCommitInfo")
	proto.RegisterType((*ResourceInfo)(nil), "cygnus.ResourceInfo")
	proto.RegisterType((*FieldIndexInfo)(nil), "cygnus.FieldIndexInfo")
	proto.RegisterType((*ManifestFileUpdate)(nil), "cygnus.ManifestFileUpdate")
	proto.RegisterType((*AddedDataFiles)(nil), "cygnus.AddedDataFiles")
	proto.RegisterType((*EmbeddedAddedDataFiles)(nil), "cygnus.EmbeddedAddedDataFiles")
	proto.RegisterType((*LargeAddedDataFiles)(nil), "cygnus.LargeAddedDataFiles")
	proto.RegisterType((*AddedDataFile)(nil), "cygnus.AddedDataFile")
	proto.RegisterType((*SchemaReference)(nil), "cygnus.SchemaReference")
}

func init() { proto.RegisterFile("kinesis.proto", fileDescriptor_1ca670e82d9f05f1) }

var fileDescriptor_1ca670e82d9f05f1 = []byte{
	// 1385 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0x4b, 0x6f, 0x1c, 0xc5,
	0x13, 0xdf, 0xb6, 0x1d, 0xdb, 0x5b, 0x7e, 0x6d, 0xda, 0x5e, 0x67, 0xed, 0xc4, 0xf3, 0x77, 0xc6,
	0xff, 0x24, 0x56, 0x90, 0x36, 0xb2, 0x11, 0x28, 0x09, 0x49, 0x50, 0x6c, 0x62, 0xb4, 0xc8, 0x89,
	0x42, 0x3b, 0x59, 0x24, 0x84, 0x84, 0xc6, 0x33, 0xbd, 0xf6, 0x28, 0xbb, 0x3d, 0xcb, 0x3c, 0x92,
	0x98, 0x13, 0x1f, 0x80, 0x03, 0xe2, 0xcc, 0x07, 0xe0, 0x6b, 0x20, 0x2e, 0x1c, 0x38, 0xe4, 0x18,
	0x6e, 0x78, 0xcd, 0x81, 0x63, 0xce, 0x48, 0x20, 0xd4, 0x3d, 0xaf, 0xee, 0x99, 0x5e, 0x07, 0xdf,
	0x76, 0xaa, 0x7e, 0xf5, 0xeb, 0xaa, 0xee, 0xae, 0x47, 0x2f, 0xcc, 0x3c, 0x73, 0x19, 0x0d, 0xdc,
	0xa0, 0xd9, 0xf7, 0xbd, 0xd0, 0xc3, 0xe3, 0xf6, 0xd1, 0x01, 0x8b, 0x82, 0xe5, 0x85, 0x03, 0xef,
	0xc0, 0x13, 0xa2, 0x1b, 0xfc, 0x57, 0xac, 0x35, 0xbf, 0x45, 0x30, 0xff, 0x91, 0x15, 0x5a, 0x3b,
	0x6e, 0x97, 0x3e, 0x60, 0xa1, 0x7f, 0x44, 0xa8, 0xed, 0xf9, 0x0e, 0xfe, 0x00, 0x66, 0x1c, 0x59,
	0xdc, 0x40, 0xab, 0x68, 0x7d, 0x6a, 0xb3, 0xde, 0x8c, 0xd9, 0x9a, 0xaa, 0x8d, 0x8a, 0xc5, 0x37,
	0x61, 0x3a, 0x15, 0xb4, 0x58, 0xc7, 0x6b, 0x8c, 0x08, 0xdb, 0x85, 0xa2, 0x2d, 0xd7, 0x11, 0x05,
	0x69, 0xfe, 0x34, 0x02, 0x33, 0x0a, 0x35, 0x6e, 0xc2, 0x58, 0x78, 0xd4, 0xa7, 0x62, 0xfd, 0xd9,
	0xcd, 0x65, 0xed, 0xfa, 0xcd, 0x27, 0x47, 0x7d, 0x4a, 0x04, 0x0e, 0xef, 0x41, 0x3d, 0x08, 0x2d,
	0xe6, 0x58, 0xbe, 0xa3, 0x60, 0x12, 0x27, 0x56, 0x52, 0x82, 0x3d, 0x1d, 0x88, 0xe8, 0x6d, 0xf1,
	0x27, 0x80, 0xbb, 0x96, 0x7f, 0x40, 0x55, 0xc6, 0x51, 0xc1, 0x98, 0xb9, 0xb4, 0x5b, 0x42, 0x10,
	0x8d, 0x95, 0xf9, 0x25, 0x8c, 0x71, 0x77, 0xf1, 0x25, 0x68, 0x28, 0x0a, 0x2e, 0x7c, 0xca, 0x9e,
	0x31, 0xef, 0x05, 0xab, 0x55, 0xf0, 0x0a, 0x2c, 0x95, 0xb4, 0xa9, 0xcb, 0x35, 0x84, 0x97, 0x61,
	0xb1, 0xa4, 0x16, 0xeb, 0xd7, 0x46, 0xcc, 0x3f, 0x10, 0xd4, 0xb5, 0xd1, 0xe1, 0x0f, 0x61, 0xe2,
	0x39, 0xf5, 0x03, 0xd7, 0x63, 0xc9, 0x76, 0x5e, 0x39, 0x75, 0x37, 0x9a, 0xed, 0x18, 0x4c, 0x52,
	0x2b, 0xbc, 0x09, 0x90, 0x1e, 0x57, 0x7b, 0x23, 0xd9, 0x51, 0x5c, 0x3c, 0x92, 0xf6, 0x06, 0x91,
	0x50, 0x66, 0x1b, 0x26, 0x12, 0x1e, 0x7c, 0x0d, 0xd6, 0xb4, 0x0b, 0x25, 0xfa, 0x3c, 0x7a, 0x13,
	0x8c, 0xd3, 0x80, 0xed, 0x8d, 0x1a, 0x32, 0x7f, 0x9b, 0x04, 0xc8, 0x97, 0xc4, 0xcb, 0x30, 0xd9,
	0x71, 0xbb, 0xf4, 0xb1, 0x15, 0x1e, 0x8a, 0xe0, 0xaa, 0x24, 0xfb, 0xe6, 0x6e, 0xf3, 0xdf, 0x3b,
	0x9e, 0xdf, 0xb3, 0x42, 0xe1, 0xf6, 0x6c, 0xee, 0xf6, 0x4e, 0xa6, 0x21, 0x12, 0x0a, 0xaf, 0xc2,
	0x94, 0x2f, 0x52, 0x61, 0xdb, 0x8b, 0x58, 0x28, 0xce, 0x7a, 0x8c, 0xc8, 0x22, 0xbc, 0x0e, 0x73,
	0x1c, 0xbf, 0xe7, 0x7e, 0x4d, 0x5b, 0x6c, 0xeb, 0x28, 0xa4, 0x41, 0x63, 0x4c, 0xa0, 0x8a, 0x62,
	0xfc, 0x00, 0xa6, 0x6c, 0xaf, 0x1b, 0xf5, 0x18, 0x17, 0x06, 0x8d, 0x73, 0xab, 0xa3, 0xeb, 0x53,
	0x9b, 0x6b, 0xe5, 0x7d, 0x6b, 0x6e, 0xe7, 0xa8, 0xf8, 0x02, 0xc9, 0x76, 0x9c, 0xe6, 0xb9, 0xd5,
	0x8d, 0xa8, 0x58, 0x3e, 0x68, 0x8c, 0x0f, 0xa5, 0x69, 0xe7, 0xa8, 0x84, 0x46, 0xb2, 0xc3, 0x9f,
	0xc2, 0x1c, 0x8b, 0xba, 0x5d, 0x09, 0xd4, 0x98, 0x10, 0x54, 0xd7, 0x34, 0x54, 0x8f, 0x54, 0x64,
	0x4c, 0x57, 0xb4, 0xc7, 0x8f, 0x60, 0x96, 0x59, 0x4c, 0x66, 0x9c, 0x14, 0x8c, 0x57, 0x75, 0x8c,
	0x0a, 0x30, 0x26, 0x2c, 0x58, 0xf3, 0x48, 0xbb, 0xde, 0x0b, 0xea, 0x6f, 0x79, 0x11, 0x73, 0x82,
	0x46, 0x75, 0x68, 0xa4, 0xbb, 0x39, 0x2a, 0x89, 0x54, 0xb2, 0xe3, 0x34, 0x51, 0xbf, 0x9f, 0xd1,
	0xc0, 0x50, 0x9a, 0xa7, 0x39, 0x2a, 0xa1, 0x91, 0xec, 0xf0, 0xff, 0x61, 0xc6, 0x65, 0x0e, 0x7d,
	0x49, 0x9d, 0x1d, 0x97, 0x76, 0x9d, 0xa0, 0x31, 0xb5, 0x3a, 0xba, 0x5e, 0x25, 0xaa, 0x10, 0x6f,
	0x43, 0x2d, 0xb0, 0x0f, 0x69, 0xcf, 0x22, 0xb4, 0x43, 0x7d, 0xca, 0x6c, 0x1a, 0x34, 0xa6, 0xc5,
	0x8a, 0x17, 0xb2, 0x2c, 0x53, 0xf5, 0xa4, 0x64, 0xb0, 0x7c, 0x0f, 0x6a, 0xc5, 0x3b, 0x80, 0x6b,
	0x30, 0xfa, 0x8c, 0xc6, 0x05, 0x78, 0x8e, 0xf0, 0x9f, 0x78, 0x01, 0xce, 0x89, 0x03, 0x15, 0x57,
	0x79, 0x8c, 0xc4, 0x1f, 0xb7, 0x47, 0x6e, 0x22, 0x6e, 0x5f, 0xdc, 0xdc, 0x33, 0xd9, 0x6f, 0xc1,
	0x82, 0xee, 0xc4, 0xcf, 0xc4, 0x71, 0x1f, 0xe6, 0x35, 0x67, 0x7c, 0xd6, 0x30, 0x8a, 0x27, 0xfb,
	0x36, 0xfb, 0xe9, 0x82, 0x7d, 0xf1, 0x48, 0xcf, 0x62, 0x6f, 0x5e, 0x05, 0x5c, 0xae, 0xe6, 0x32,
	0x43, 0x55, 0x30, 0x98, 0x5d, 0x98, 0x96, 0x9b, 0xd9, 0xa9, 0x45, 0xc8, 0x84, 0x69, 0xdb, 0xa7,
	0x56, 0xe8, 0x7a, 0xec, 0x89, 0xdb, 0x4b, 0x83, 0x56, 0x64, 0xf8, 0x12, 0x54, 0x2d, 0xdb, 0xe6,
	0x9b, 0xd6, 0x72, 0x44, 0xc9, 0xa9, 0x92, 0x5c, 0x60, 0xfe, 0x85, 0x60, 0xe1, 0x21, 0x0d, 0x2d,
	0x5e, 0x5c, 0xb7, 0xbd, 0x5e, 0xcf, 0x0d, 0x93, 0x66, 0xfd, 0x9e, 0xd2, 0x23, 0x2f, 0xa7, 0xd7,
	0x4d, 0x87, 0x95, 0x5b, 0xe5, 0x43, 0x98, 0x77, 0x6d, 0xba, 0x4f, 0xfd, 0x03, 0x19, 0x91, 0x94,
	0xf5, 0x8b, 0x29, 0x4b, 0xab, 0x0c, 0x21, 0x3a, 0x3b, 0xf3, 0x8b, 0xa4, 0xb1, 0xad, 0xc1, 0xff,
	0x74, 0x2b, 0xab, 0xfd, 0xed, 0x06, 0xbc, 0x33, 0x0c, 0xa4, 0x59, 0xb0, 0x86, 0xcc, 0xbf, 0x11,
	0xcc, 0x6b, 0x34, 0xf8, 0x6e, 0xb1, 0xa7, 0xad, 0x9d, 0xe2, 0x78, 0xb9, 0xa3, 0xed, 0x41, 0x5d,
	0x13, 0x4b, 0xd6, 0xdc, 0x56, 0x4e, 0x21, 0x6b, 0x6f, 0x10, 0xbd, 0xad, 0x49, 0xf2, 0x96, 0x77,
	0x05, 0x2e, 0xeb, 0x4c, 0x8b, 0x0d, 0x6f, 0x15, 0x2e, 0x0d, 0x87, 0x89, 0x76, 0xf7, 0x3d, 0x82,
	0xba, 0xd6, 0x09, 0x7c, 0x0b, 0xc0, 0x16, 0x12, 0x31, 0x6b, 0xc5, 0x73, 0xda, 0x92, 0xd6, 0x6f,
	0x31, 0x70, 0x49, 0x60, 0x7c, 0x0f, 0x66, 0x3b, 0xbc, 0x7a, 0xb5, 0x78, 0x25, 0x93, 0x46, 0xb5,
	0xc5, 0xbc, 0x39, 0xca, 0x5a, 0x52, 0x40, 0x9b, 0x3f, 0x23, 0x38, 0x5f, 0x5a, 0x81, 0x8f, 0x7f,
	0x3e, 0x0d, 0xbc, 0xc8, 0xb7, 0xa9, 0xe4, 0x52, 0x36, 0xfe, 0x11, 0x49, 0x47, 0x14, 0x24, 0x9f,
	0xb3, 0x7a, 0x16, 0x73, 0x3b, 0x34, 0x08, 0x79, 0x4e, 0x3d, 0xed, 0x3b, 0x56, 0x48, 0x13, 0x9f,
	0xb2, 0x39, 0xeb, 0x61, 0x09, 0x41, 0x34, 0x56, 0xbc, 0x3d, 0xc7, 0x91, 0xf2, 0xcc, 0x0a, 0x42,
	0xab, 0xd7, 0x4f, 0x9a, 0x78, 0x51, 0x6c, 0xfe, 0x80, 0x60, 0x5a, 0x76, 0x4a, 0x4d, 0x43, 0x54,
	0x48, 0x43, 0x9e, 0xc8, 0x5d, 0xef, 0xe0, 0x63, 0xdf, 0x8b, 0xfa, 0x8f, 0xac, 0x24, 0x91, 0xab,
	0x44, 0x91, 0xe1, 0x26, 0xe0, 0xf4, 0xbb, 0xc5, 0x42, 0xea, 0x33, 0xab, 0x9b, 0x65, 0xb4, 0x46,
	0xc3, 0x0b, 0x47, 0xdc, 0x0b, 0x5a, 0x8e, 0x18, 0x22, 0xaa, 0x24, 0xfb, 0x36, 0xdf, 0x87, 0x59,
	0xf5, 0x18, 0xca, 0x0d, 0x09, 0x69, 0x1a, 0x92, 0xf9, 0x0f, 0x02, 0x5c, 0xde, 0x2b, 0xbc, 0x03,
	0x46, 0xdf, 0xa7, 0xcf, 0x5d, 0x2f, 0x0a, 0x64, 0x2d, 0xaf, 0x51, 0x7b, 0x51, 0xa7, 0xe3, 0xbe,
	0x4c, 0x22, 0x7e, 0x0b, 0x0a, 0xdf, 0x81, 0x25, 0x46, 0x5f, 0x0c, 0xa1, 0x88, 0xf7, 0x64, 0x38,
	0x80, 0x6f, 0xe2, 0xbe, 0x15, 0xd0, 0x5d, 0xcf, 0x16, 0xd5, 0x2f, 0xd9, 0x1a, 0x45, 0xc6, 0x6f,
	0xa7, 0xe5, 0x38, 0x34, 0x1b, 0x01, 0xe3, 0xf9, 0x4a, 0xba, 0x9d, 0xf7, 0x15, 0x2d, 0x29, 0xa0,
	0xcd, 0x5f, 0x47, 0x60, 0x56, 0x85, 0xe0, 0x1b, 0x4a, 0xa5, 0xbc, 0xa8, 0x27, 0x92, 0x6b, 0x64,
	0x1b, 0x16, 0x69, 0x6f, 0x9f, 0x72, 0xbd, 0x0a, 0x4a, 0x6e, 0xa5, 0x91, 0x52, 0x3c, 0xd0, 0xa2,
	0xc8, 0x10, 0x6b, 0x5e, 0x7b, 0xc5, 0xdb, 0xa0, 0x40, 0x3a, 0xaa, 0xd6, 0xde, 0xdd, 0x32, 0x84,
	0xe8, 0xec, 0xcc, 0xfd, 0xa4, 0xf6, 0xae, 0xc0, 0x92, 0xaa, 0x51, 0xab, 0xae, 0x01, 0xcb, 0x65,
	0x75, 0xea, 0x79, 0x0d, 0xe1, 0x8b, 0x70, 0xa1, 0xac, 0x4f, 0xdf, 0x15, 0x9f, 0xc1, 0xa2, 0x3e,
	0x48, 0x7c, 0xb7, 0x74, 0x50, 0x48, 0x0c, 0x3e, 0x75, 0xed, 0xfe, 0x96, 0xce, 0xe9, 0x1a, 0xcc,
	0x6b, 0x02, 0xd5, 0xb4, 0xdb, 0xe3, 0x11, 0x98, 0x51, 0x40, 0x3c, 0xcf, 0xd2, 0xa7, 0x46, 0xe9,
	0x02, 0x6b, 0x34, 0x78, 0x13, 0x16, 0xe4, 0x52, 0xf1, 0xd8, 0x0b, 0x5c, 0x71, 0xfd, 0xf8, 0x61,
	0xce, 0x10, 0xad, 0x8e, 0x67, 0x5b, 0x98, 0xd6, 0x8a, 0x1d, 0xdf, 0xeb, 0x25, 0x65, 0x44, 0x15,
	0xf2, 0xf7, 0x42, 0x26, 0x78, 0xe2, 0x25, 0x2f, 0x01, 0x59, 0x54, 0x7c, 0x51, 0x9c, 0x2b, 0xbf,
	0x28, 0xae, 0x43, 0x2d, 0x62, 0xb6, 0xd7, 0xeb, 0xfb, 0x34, 0x08, 0xa8, 0xc3, 0x67, 0xc0, 0xc6,
	0xb8, 0x80, 0x95, 0xe4, 0xa5, 0x71, 0x62, 0x42, 0x33, 0x4e, 0xa8, 0xef, 0x9e, 0xc9, 0xff, 0xf2,
	0xee, 0x31, 0x6f, 0xc1, 0x5c, 0x61, 0x4c, 0xc5, 0x18, 0xc6, 0x18, 0x2f, 0x74, 0xf1, 0xb6, 0x8a,
	0xdf, 0x5c, 0x76, 0x68, 0x05, 0x87, 0x49, 0xa2, 0x8b, 0xdf, 0xd7, 0x6f, 0x03, 0xe4, 0xa4, 0xb8,
	0x0e, 0xe7, 0xf3, 0xaf, 0xfc, 0x0a, 0x2a, 0xe2, 0xc7, 0x96, 0xff, 0x55, 0x44, 0xc3, 0x1a, 0xda,
	0xba, 0xf3, 0xea, 0xd8, 0xa8, 0xbc, 0x3e, 0x36, 0x2a, 0x6f, 0x8e, 0x0d, 0xf4, 0xcd, 0xc0, 0x40,
	0x3f, 0x0e, 0x0c, 0xf4, 0xcb, 0xc0, 0x40, 0xaf, 0x06, 0x06, 0xfa, 0x7d, 0x60, 0xa0, 0x3f, 0x07,
	0x46, 0xe5, 0xcd, 0xc0, 0x40, 0xdf, 0x9d, 0x18, 0x95, 0x57, 0x27, 0x46, 0xe5, 0xf5, 0x89, 0x51,
	0xf9, 0x3c, 0xf9, 0x6f, 0x63, 0x7f, 0x5c, 0xfc, 0x99, 0xf1, 0xee, 0xbf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x1a, 0x13, 0xd0, 0xb9, 0xfb, 0x10, 0x00, 0x00,
}

func (x FileFormat) String() string {
	s, ok := FileFormat_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x DataFileEntry_Type) String() string {
	s, ok := DataFileEntry_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x StandardDataFileEntry_Version) String() string {
	s, ok := StandardDataFileEntry_Version_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MetadataCommitRecord_Type) String() string {
	s, ok := MetadataCommitRecord_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x IcebergCommitRecord_Version) String() string {
	s, ok := IcebergCommitRecord_Version_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x AddedDataFiles_Type) String() string {
	s, ok := AddedDataFiles_Type_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *DataFileEntryRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataFileEntryRecord)
	if !ok {
		that2, ok := that.(DataFileEntryRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DataFileEntry.Equal(that1.DataFileEntry) {
		return false
	}
	if !this.DataFileInfo.Equal(that1.DataFileInfo) {
		return false
	}
	return true
}
func (this *DataFileEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataFileEntry)
	if !ok {
		that2, ok := that.(DataFileEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.StandardDataFileEntry.Equal(that1.StandardDataFileEntry) {
		return false
	}
	if !this.LargeDataFileEntry.Equal(that1.LargeDataFileEntry) {
		return false
	}
	return true
}
func (this *StandardDataFileEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StandardDataFileEntry)
	if !ok {
		that2, ok := that.(StandardDataFileEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.DataFileV1.Equal(that1.DataFileV1) {
		return false
	}
	return true
}
func (this *DataFileV1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataFileV1)
	if !ok {
		that2, ok := that.(DataFileV1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if this.FileFormat != that1.FileFormat {
		return false
	}
	if this.RecordCount != that1.RecordCount {
		return false
	}
	if this.FileSizeInBytes != that1.FileSizeInBytes {
		return false
	}
	if len(this.ColumnSizes) != len(that1.ColumnSizes) {
		return false
	}
	for i := range this.ColumnSizes {
		if this.ColumnSizes[i] != that1.ColumnSizes[i] {
			return false
		}
	}
	if len(this.ValueCounts) != len(that1.ValueCounts) {
		return false
	}
	for i := range this.ValueCounts {
		if this.ValueCounts[i] != that1.ValueCounts[i] {
			return false
		}
	}
	if len(this.NullValueCounts) != len(that1.NullValueCounts) {
		return false
	}
	for i := range this.NullValueCounts {
		if this.NullValueCounts[i] != that1.NullValueCounts[i] {
			return false
		}
	}
	if len(this.NanValueCounts) != len(that1.NanValueCounts) {
		return false
	}
	for i := range this.NanValueCounts {
		if this.NanValueCounts[i] != that1.NanValueCounts[i] {
			return false
		}
	}
	if len(this.LowerBounds) != len(that1.LowerBounds) {
		return false
	}
	for i := range this.LowerBounds {
		if !bytes.Equal(this.LowerBounds[i], that1.LowerBounds[i]) {
			return false
		}
	}
	if len(this.UpperBounds) != len(that1.UpperBounds) {
		return false
	}
	for i := range this.UpperBounds {
		if !bytes.Equal(this.UpperBounds[i], that1.UpperBounds[i]) {
			return false
		}
	}
	if len(this.IndexedFields) != len(that1.IndexedFields) {
		return false
	}
	for i := range this.IndexedFields {
		if this.IndexedFields[i] != that1.IndexedFields[i] {
			return false
		}
	}
	if len(this.SchemaReferences) != len(that1.SchemaReferences) {
		return false
	}
	for i := range this.SchemaReferences {
		if !this.SchemaReferences[i].Equal(that1.SchemaReferences[i]) {
			return false
		}
	}
	return true
}
func (this *LargeDataFileEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LargeDataFileEntry)
	if !ok {
		that2, ok := that.(LargeDataFileEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *DataFileInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataFileInfo)
	if !ok {
		that2, ok := that.(DataFileInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if this.CreationTime != that1.CreationTime {
		return false
	}
	if this.AccountId != that1.AccountId {
		return false
	}
	return true
}
func (this *MetadataCommitRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetadataCommitRecord)
	if !ok {
		that2, ok := that.(MetadataCommitRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.IcebergCommitRecord.Equal(that1.IcebergCommitRecord) {
		return false
	}
	return true
}
func (this *IcebergCommitRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IcebergCommitRecord)
	if !ok {
		that2, ok := that.(IcebergCommitRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.IcebergCommitRecordV1.Equal(that1.IcebergCommitRecordV1) {
		return false
	}
	return true
}
func (this *IcebergCommitRecordV1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IcebergCommitRecordV1)
	if !ok {
		that2, ok := that.(IcebergCommitRecordV1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CommitInfo.Equal(that1.CommitInfo) {
		return false
	}
	if !this.FieldIndexInfo.Equal(that1.FieldIndexInfo) {
		return false
	}
	return true
}
func (this *IcebergCommitInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IcebergCommitInfo)
	if !ok {
		that2, ok := that.(IcebergCommitInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResourceInfo.Equal(that1.ResourceInfo) {
		return false
	}
	if !this.ManifestFileUpdate.Equal(that1.ManifestFileUpdate) {
		return false
	}
	if this.CommitTimestamp != that1.CommitTimestamp {
		return false
	}
	return true
}
func (this *ResourceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResourceInfo)
	if !ok {
		that2, ok := that.(ResourceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountId != that1.AccountId {
		return false
	}
	if this.LogGroupName != that1.LogGroupName {
		return false
	}
	if this.LogGroupInternalId != that1.LogGroupInternalId {
		return false
	}
	if this.SchemaId != that1.SchemaId {
		return false
	}
	return true
}
func (this *FieldIndexInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldIndexInfo)
	if !ok {
		that2, ok := that.(FieldIndexInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.IndexedFields) != len(that1.IndexedFields) {
		return false
	}
	for i := range this.IndexedFields {
		if this.IndexedFields[i] != that1.IndexedFields[i] {
			return false
		}
	}
	return true
}
func (this *ManifestFileUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ManifestFileUpdate)
	if !ok {
		that2, ok := that.(ManifestFileUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PreviousManifestFilePathSuffix != that1.PreviousManifestFilePathSuffix {
		return false
	}
	if this.NewManifestFilePathSuffix != that1.NewManifestFilePathSuffix {
		return false
	}
	if this.BaseLocation != that1.BaseLocation {
		return false
	}
	if !this.AddedDataFiles.Equal(that1.AddedDataFiles) {
		return false
	}
	return true
}
func (this *AddedDataFiles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddedDataFiles)
	if !ok {
		that2, ok := that.(AddedDataFiles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !this.EmbeddedAddedDataFiles.Equal(that1.EmbeddedAddedDataFiles) {
		return false
	}
	if !this.LargeAddedDataFiles.Equal(that1.LargeAddedDataFiles) {
		return false
	}
	return true
}
func (this *EmbeddedAddedDataFiles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EmbeddedAddedDataFiles)
	if !ok {
		that2, ok := that.(EmbeddedAddedDataFiles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.AddedDataFiles) != len(that1.AddedDataFiles) {
		return false
	}
	for i := range this.AddedDataFiles {
		if !this.AddedDataFiles[i].Equal(that1.AddedDataFiles[i]) {
			return false
		}
	}
	return true
}
func (this *LargeAddedDataFiles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LargeAddedDataFiles)
	if !ok {
		that2, ok := that.(LargeAddedDataFiles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	return true
}
func (this *AddedDataFile) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddedDataFile)
	if !ok {
		that2, ok := that.(AddedDataFile)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DataFilePathSuffix != that1.DataFilePathSuffix {
		return false
	}
	if this.ManifestFilePosition != that1.ManifestFilePosition {
		return false
	}
	if this.TimestampFrom != that1.TimestampFrom {
		return false
	}
	if this.TimestampTo != that1.TimestampTo {
		return false
	}
	if this.RecordCount != that1.RecordCount {
		return false
	}
	if this.UncompressedSize != that1.UncompressedSize {
		return false
	}
	if this.CreationTime != that1.CreationTime {
		return false
	}
	if this.FileFormat != that1.FileFormat {
		return false
	}
	return true
}
func (this *SchemaReference) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SchemaReference)
	if !ok {
		that2, ok := that.(SchemaReference)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Hash != that1.Hash {
		return false
	}
	return true
}
func (this *DataFileEntryRecord) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cygnus.DataFileEntryRecord{")
	if this.DataFileEntry != nil {
		s = append(s, "DataFileEntry: "+fmt.Sprintf("%#v", this.DataFileEntry)+",\n")
	}
	if this.DataFileInfo != nil {
		s = append(s, "DataFileInfo: "+fmt.Sprintf("%#v", this.DataFileInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataFileEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cygnus.DataFileEntry{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.StandardDataFileEntry != nil {
		s = append(s, "StandardDataFileEntry: "+fmt.Sprintf("%#v", this.StandardDataFileEntry)+",\n")
	}
	if this.LargeDataFileEntry != nil {
		s = append(s, "LargeDataFileEntry: "+fmt.Sprintf("%#v", this.LargeDataFileEntry)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StandardDataFileEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cygnus.StandardDataFileEntry{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.DataFileV1 != nil {
		s = append(s, "DataFileV1: "+fmt.Sprintf("%#v", this.DataFileV1)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataFileV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&cygnus.DataFileV1{")
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "FileFormat: "+fmt.Sprintf("%#v", this.FileFormat)+",\n")
	s = append(s, "RecordCount: "+fmt.Sprintf("%#v", this.RecordCount)+",\n")
	s = append(s, "FileSizeInBytes: "+fmt.Sprintf("%#v", this.FileSizeInBytes)+",\n")
	keysForColumnSizes := make([]int32, 0, len(this.ColumnSizes))
	for k, _ := range this.ColumnSizes {
		keysForColumnSizes = append(keysForColumnSizes, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForColumnSizes)
	mapStringForColumnSizes := "map[int32]uint64{"
	for _, k := range keysForColumnSizes {
		mapStringForColumnSizes += fmt.Sprintf("%#v: %#v,", k, this.ColumnSizes[k])
	}
	mapStringForColumnSizes += "}"
	if this.ColumnSizes != nil {
		s = append(s, "ColumnSizes: "+mapStringForColumnSizes+",\n")
	}
	keysForValueCounts := make([]int32, 0, len(this.ValueCounts))
	for k, _ := range this.ValueCounts {
		keysForValueCounts = append(keysForValueCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForValueCounts)
	mapStringForValueCounts := "map[int32]uint64{"
	for _, k := range keysForValueCounts {
		mapStringForValueCounts += fmt.Sprintf("%#v: %#v,", k, this.ValueCounts[k])
	}
	mapStringForValueCounts += "}"
	if this.ValueCounts != nil {
		s = append(s, "ValueCounts: "+mapStringForValueCounts+",\n")
	}
	keysForNullValueCounts := make([]int32, 0, len(this.NullValueCounts))
	for k, _ := range this.NullValueCounts {
		keysForNullValueCounts = append(keysForNullValueCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNullValueCounts)
	mapStringForNullValueCounts := "map[int32]uint64{"
	for _, k := range keysForNullValueCounts {
		mapStringForNullValueCounts += fmt.Sprintf("%#v: %#v,", k, this.NullValueCounts[k])
	}
	mapStringForNullValueCounts += "}"
	if this.NullValueCounts != nil {
		s = append(s, "NullValueCounts: "+mapStringForNullValueCounts+",\n")
	}
	keysForNanValueCounts := make([]int32, 0, len(this.NanValueCounts))
	for k, _ := range this.NanValueCounts {
		keysForNanValueCounts = append(keysForNanValueCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNanValueCounts)
	mapStringForNanValueCounts := "map[int32]uint64{"
	for _, k := range keysForNanValueCounts {
		mapStringForNanValueCounts += fmt.Sprintf("%#v: %#v,", k, this.NanValueCounts[k])
	}
	mapStringForNanValueCounts += "}"
	if this.NanValueCounts != nil {
		s = append(s, "NanValueCounts: "+mapStringForNanValueCounts+",\n")
	}
	keysForLowerBounds := make([]int32, 0, len(this.LowerBounds))
	for k, _ := range this.LowerBounds {
		keysForLowerBounds = append(keysForLowerBounds, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForLowerBounds)
	mapStringForLowerBounds := "map[int32][]byte{"
	for _, k := range keysForLowerBounds {
		mapStringForLowerBounds += fmt.Sprintf("%#v: %#v,", k, this.LowerBounds[k])
	}
	mapStringForLowerBounds += "}"
	if this.LowerBounds != nil {
		s = append(s, "LowerBounds: "+mapStringForLowerBounds+",\n")
	}
	keysForUpperBounds := make([]int32, 0, len(this.UpperBounds))
	for k, _ := range this.UpperBounds {
		keysForUpperBounds = append(keysForUpperBounds, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForUpperBounds)
	mapStringForUpperBounds := "map[int32][]byte{"
	for _, k := range keysForUpperBounds {
		mapStringForUpperBounds += fmt.Sprintf("%#v: %#v,", k, this.UpperBounds[k])
	}
	mapStringForUpperBounds += "}"
	if this.UpperBounds != nil {
		s = append(s, "UpperBounds: "+mapStringForUpperBounds+",\n")
	}
	s = append(s, "IndexedFields: "+fmt.Sprintf("%#v", this.IndexedFields)+",\n")
	if this.SchemaReferences != nil {
		s = append(s, "SchemaReferences: "+fmt.Sprintf("%#v", this.SchemaReferences)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LargeDataFileEntry) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cygnus.LargeDataFileEntry{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataFileInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cygnus.DataFileInfo{")
	s = append(s, "FilePath: "+fmt.Sprintf("%#v", this.FilePath)+",\n")
	s = append(s, "CreationTime: "+fmt.Sprintf("%#v", this.CreationTime)+",\n")
	s = append(s, "AccountId: "+fmt.Sprintf("%#v", this.AccountId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MetadataCommitRecord) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cygnus.MetadataCommitRecord{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.IcebergCommitRecord != nil {
		s = append(s, "IcebergCommitRecord: "+fmt.Sprintf("%#v", this.IcebergCommitRecord)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IcebergCommitRecord) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cygnus.IcebergCommitRecord{")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	if this.IcebergCommitRecordV1 != nil {
		s = append(s, "IcebergCommitRecordV1: "+fmt.Sprintf("%#v", this.IcebergCommitRecordV1)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IcebergCommitRecordV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cygnus.IcebergCommitRecordV1{")
	if this.CommitInfo != nil {
		s = append(s, "CommitInfo: "+fmt.Sprintf("%#v", this.CommitInfo)+",\n")
	}
	if this.FieldIndexInfo != nil {
		s = append(s, "FieldIndexInfo: "+fmt.Sprintf("%#v", this.FieldIndexInfo)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *IcebergCommitInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cygnus.IcebergCommitInfo{")
	if this.ResourceInfo != nil {
		s = append(s, "ResourceInfo: "+fmt.Sprintf("%#v", this.ResourceInfo)+",\n")
	}
	if this.ManifestFileUpdate != nil {
		s = append(s, "ManifestFileUpdate: "+fmt.Sprintf("%#v", this.ManifestFileUpdate)+",\n")
	}
	s = append(s, "CommitTimestamp: "+fmt.Sprintf("%#v", this.CommitTimestamp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cygnus.ResourceInfo{")
	s = append(s, "AccountId: "+fmt.Sprintf("%#v", this.AccountId)+",\n")
	s = append(s, "LogGroupName: "+fmt.Sprintf("%#v", this.LogGroupName)+",\n")
	s = append(s, "LogGroupInternalId: "+fmt.Sprintf("%#v", this.LogGroupInternalId)+",\n")
	s = append(s, "SchemaId: "+fmt.Sprintf("%#v", this.SchemaId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldIndexInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cygnus.FieldIndexInfo{")
	s = append(s, "IndexedFields: "+fmt.Sprintf("%#v", this.IndexedFields)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ManifestFileUpdate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&cygnus.ManifestFileUpdate{")
	s = append(s, "PreviousManifestFilePathSuffix: "+fmt.Sprintf("%#v", this.PreviousManifestFilePathSuffix)+",\n")
	s = append(s, "NewManifestFilePathSuffix: "+fmt.Sprintf("%#v", this.NewManifestFilePathSuffix)+",\n")
	s = append(s, "BaseLocation: "+fmt.Sprintf("%#v", this.BaseLocation)+",\n")
	if this.AddedDataFiles != nil {
		s = append(s, "AddedDataFiles: "+fmt.Sprintf("%#v", this.AddedDataFiles)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddedDataFiles) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&cygnus.AddedDataFiles{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	if this.EmbeddedAddedDataFiles != nil {
		s = append(s, "EmbeddedAddedDataFiles: "+fmt.Sprintf("%#v", this.EmbeddedAddedDataFiles)+",\n")
	}
	if this.LargeAddedDataFiles != nil {
		s = append(s, "LargeAddedDataFiles: "+fmt.Sprintf("%#v", this.LargeAddedDataFiles)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmbeddedAddedDataFiles) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cygnus.EmbeddedAddedDataFiles{")
	if this.AddedDataFiles != nil {
		s = append(s, "AddedDataFiles: "+fmt.Sprintf("%#v", this.AddedDataFiles)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LargeAddedDataFiles) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&cygnus.LargeAddedDataFiles{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AddedDataFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&cygnus.AddedDataFile{")
	s = append(s, "DataFilePathSuffix: "+fmt.Sprintf("%#v", this.DataFilePathSuffix)+",\n")
	s = append(s, "ManifestFilePosition: "+fmt.Sprintf("%#v", this.ManifestFilePosition)+",\n")
	s = append(s, "TimestampFrom: "+fmt.Sprintf("%#v", this.TimestampFrom)+",\n")
	s = append(s, "TimestampTo: "+fmt.Sprintf("%#v", this.TimestampTo)+",\n")
	s = append(s, "RecordCount: "+fmt.Sprintf("%#v", this.RecordCount)+",\n")
	s = append(s, "UncompressedSize: "+fmt.Sprintf("%#v", this.UncompressedSize)+",\n")
	s = append(s, "CreationTime: "+fmt.Sprintf("%#v", this.CreationTime)+",\n")
	s = append(s, "FileFormat: "+fmt.Sprintf("%#v", this.FileFormat)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SchemaReference) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&cygnus.SchemaReference{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringKinesis(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *DataFileEntryRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileEntryRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileEntryRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataFileInfo != nil {
		{
			size, err := m.DataFileInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DataFileEntry != nil {
		{
			size, err := m.DataFileEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataFileEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LargeDataFileEntry != nil {
		{
			size, err := m.LargeDataFileEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StandardDataFileEntry != nil {
		{
			size, err := m.StandardDataFileEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StandardDataFileEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StandardDataFileEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StandardDataFileEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DataFileV1 != nil {
		{
			size, err := m.DataFileV1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataFileV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchemaReferences) > 0 {
		for iNdEx := len(m.SchemaReferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SchemaReferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKinesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.IndexedFields) > 0 {
		for iNdEx := len(m.IndexedFields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexedFields[iNdEx])
			copy(dAtA[i:], m.IndexedFields[iNdEx])
			i = encodeVarintKinesis(dAtA, i, uint64(len(m.IndexedFields[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.UpperBounds) > 0 {
		for k := range m.UpperBounds {
			v := m.UpperBounds[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintKinesis(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintKinesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.LowerBounds) > 0 {
		for k := range m.LowerBounds {
			v := m.LowerBounds[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintKinesis(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintKinesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.NanValueCounts) > 0 {
		for k := range m.NanValueCounts {
			v := m.NanValueCounts[k]
			baseI := i
			i = encodeVarintKinesis(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintKinesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.NullValueCounts) > 0 {
		for k := range m.NullValueCounts {
			v := m.NullValueCounts[k]
			baseI := i
			i = encodeVarintKinesis(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintKinesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ValueCounts) > 0 {
		for k := range m.ValueCounts {
			v := m.ValueCounts[k]
			baseI := i
			i = encodeVarintKinesis(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintKinesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ColumnSizes) > 0 {
		for k := range m.ColumnSizes {
			v := m.ColumnSizes[k]
			baseI := i
			i = encodeVarintKinesis(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(k))
			i--
			dAtA[i] = 0xd
			i = encodeVarintKinesis(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.FileSizeInBytes != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.FileSizeInBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.RecordCount != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.RecordCount))
		i--
		dAtA[i] = 0x18
	}
	if m.FileFormat != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.FileFormat))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LargeDataFileEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LargeDataFileEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LargeDataFileEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataFileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataFileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataFileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CreationTime != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.CreationTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetadataCommitRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataCommitRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataCommitRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IcebergCommitRecord != nil {
		{
			size, err := m.IcebergCommitRecord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IcebergCommitRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcebergCommitRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IcebergCommitRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IcebergCommitRecordV1 != nil {
		{
			size, err := m.IcebergCommitRecordV1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IcebergCommitRecordV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcebergCommitRecordV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IcebergCommitRecordV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FieldIndexInfo != nil {
		{
			size, err := m.FieldIndexInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CommitInfo != nil {
		{
			size, err := m.CommitInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IcebergCommitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IcebergCommitInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IcebergCommitInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommitTimestamp != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.CommitTimestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.ManifestFileUpdate != nil {
		{
			size, err := m.ManifestFileUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ResourceInfo != nil {
		{
			size, err := m.ResourceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchemaId) > 0 {
		i -= len(m.SchemaId)
		copy(dAtA[i:], m.SchemaId)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.SchemaId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LogGroupInternalId) > 0 {
		i -= len(m.LogGroupInternalId)
		copy(dAtA[i:], m.LogGroupInternalId)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.LogGroupInternalId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LogGroupName) > 0 {
		i -= len(m.LogGroupName)
		copy(dAtA[i:], m.LogGroupName)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.LogGroupName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountId) > 0 {
		i -= len(m.AccountId)
		copy(dAtA[i:], m.AccountId)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.AccountId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FieldIndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldIndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FieldIndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexedFields) > 0 {
		for iNdEx := len(m.IndexedFields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IndexedFields[iNdEx])
			copy(dAtA[i:], m.IndexedFields[iNdEx])
			i = encodeVarintKinesis(dAtA, i, uint64(len(m.IndexedFields[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ManifestFileUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManifestFileUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManifestFileUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AddedDataFiles != nil {
		{
			size, err := m.AddedDataFiles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseLocation) > 0 {
		i -= len(m.BaseLocation)
		copy(dAtA[i:], m.BaseLocation)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.BaseLocation)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NewManifestFilePathSuffix) > 0 {
		i -= len(m.NewManifestFilePathSuffix)
		copy(dAtA[i:], m.NewManifestFilePathSuffix)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.NewManifestFilePathSuffix)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousManifestFilePathSuffix) > 0 {
		i -= len(m.PreviousManifestFilePathSuffix)
		copy(dAtA[i:], m.PreviousManifestFilePathSuffix)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.PreviousManifestFilePathSuffix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddedDataFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddedDataFiles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddedDataFiles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LargeAddedDataFiles != nil {
		{
			size, err := m.LargeAddedDataFiles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EmbeddedAddedDataFiles != nil {
		{
			size, err := m.EmbeddedAddedDataFiles.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKinesis(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EmbeddedAddedDataFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmbeddedAddedDataFiles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EmbeddedAddedDataFiles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddedDataFiles) > 0 {
		for iNdEx := len(m.AddedDataFiles) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddedDataFiles[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKinesis(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LargeAddedDataFiles) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LargeAddedDataFiles) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LargeAddedDataFiles) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddedDataFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddedDataFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddedDataFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileFormat != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.FileFormat))
		i--
		dAtA[i] = 0x40
	}
	if m.CreationTime != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.CreationTime))
		i--
		dAtA[i] = 0x38
	}
	if m.UncompressedSize != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.UncompressedSize))
		i--
		dAtA[i] = 0x30
	}
	if m.RecordCount != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.RecordCount))
		i--
		dAtA[i] = 0x28
	}
	if m.TimestampTo != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.TimestampTo))
		i--
		dAtA[i] = 0x20
	}
	if m.TimestampFrom != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.TimestampFrom))
		i--
		dAtA[i] = 0x18
	}
	if m.ManifestFilePosition != 0 {
		i = encodeVarintKinesis(dAtA, i, uint64(m.ManifestFilePosition))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DataFilePathSuffix) > 0 {
		i -= len(m.DataFilePathSuffix)
		copy(dAtA[i:], m.DataFilePathSuffix)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.DataFilePathSuffix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchemaReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchemaReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintKinesis(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintKinesis(dAtA []byte, offset int, v uint64) int {
	offset -= sovKinesis(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DataFileEntryRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataFileEntry != nil {
		l = m.DataFileEntry.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.DataFileInfo != nil {
		l = m.DataFileInfo.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *DataFileEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovKinesis(uint64(m.Type))
	}
	if m.StandardDataFileEntry != nil {
		l = m.StandardDataFileEntry.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.LargeDataFileEntry != nil {
		l = m.LargeDataFileEntry.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *StandardDataFileEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovKinesis(uint64(m.Version))
	}
	if m.DataFileV1 != nil {
		l = m.DataFileV1.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *DataFileV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.FileFormat != 0 {
		n += 1 + sovKinesis(uint64(m.FileFormat))
	}
	if m.RecordCount != 0 {
		n += 1 + sovKinesis(uint64(m.RecordCount))
	}
	if m.FileSizeInBytes != 0 {
		n += 1 + sovKinesis(uint64(m.FileSizeInBytes))
	}
	if len(m.ColumnSizes) > 0 {
		for k, v := range m.ColumnSizes {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + sovKinesis(uint64(v))
			n += mapEntrySize + 1 + sovKinesis(uint64(mapEntrySize))
		}
	}
	if len(m.ValueCounts) > 0 {
		for k, v := range m.ValueCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + sovKinesis(uint64(v))
			n += mapEntrySize + 1 + sovKinesis(uint64(mapEntrySize))
		}
	}
	if len(m.NullValueCounts) > 0 {
		for k, v := range m.NullValueCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + sovKinesis(uint64(v))
			n += mapEntrySize + 1 + sovKinesis(uint64(mapEntrySize))
		}
	}
	if len(m.NanValueCounts) > 0 {
		for k, v := range m.NanValueCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + 4 + 1 + sovKinesis(uint64(v))
			n += mapEntrySize + 1 + sovKinesis(uint64(mapEntrySize))
		}
	}
	if len(m.LowerBounds) > 0 {
		for k, v := range m.LowerBounds {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovKinesis(uint64(len(v)))
			}
			mapEntrySize := 1 + 4 + l
			n += mapEntrySize + 1 + sovKinesis(uint64(mapEntrySize))
		}
	}
	if len(m.UpperBounds) > 0 {
		for k, v := range m.UpperBounds {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovKinesis(uint64(len(v)))
			}
			mapEntrySize := 1 + 4 + l
			n += mapEntrySize + 1 + sovKinesis(uint64(mapEntrySize))
		}
	}
	if len(m.IndexedFields) > 0 {
		for _, s := range m.IndexedFields {
			l = len(s)
			n += 1 + l + sovKinesis(uint64(l))
		}
	}
	if len(m.SchemaReferences) > 0 {
		for _, e := range m.SchemaReferences {
			l = e.Size()
			n += 1 + l + sovKinesis(uint64(l))
		}
	}
	return n
}

func (m *LargeDataFileEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *DataFileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.CreationTime != 0 {
		n += 1 + sovKinesis(uint64(m.CreationTime))
	}
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *MetadataCommitRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovKinesis(uint64(m.Type))
	}
	if m.IcebergCommitRecord != nil {
		l = m.IcebergCommitRecord.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *IcebergCommitRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovKinesis(uint64(m.Version))
	}
	if m.IcebergCommitRecordV1 != nil {
		l = m.IcebergCommitRecordV1.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *IcebergCommitRecordV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitInfo != nil {
		l = m.CommitInfo.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.FieldIndexInfo != nil {
		l = m.FieldIndexInfo.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *IcebergCommitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceInfo != nil {
		l = m.ResourceInfo.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.ManifestFileUpdate != nil {
		l = m.ManifestFileUpdate.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.CommitTimestamp != 0 {
		n += 1 + sovKinesis(uint64(m.CommitTimestamp))
	}
	return n
}

func (m *ResourceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountId)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	l = len(m.LogGroupName)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	l = len(m.LogGroupInternalId)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	l = len(m.SchemaId)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *FieldIndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IndexedFields) > 0 {
		for _, s := range m.IndexedFields {
			l = len(s)
			n += 1 + l + sovKinesis(uint64(l))
		}
	}
	return n
}

func (m *ManifestFileUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousManifestFilePathSuffix)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	l = len(m.NewManifestFilePathSuffix)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	l = len(m.BaseLocation)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.AddedDataFiles != nil {
		l = m.AddedDataFiles.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *AddedDataFiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovKinesis(uint64(m.Type))
	}
	if m.EmbeddedAddedDataFiles != nil {
		l = m.EmbeddedAddedDataFiles.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.LargeAddedDataFiles != nil {
		l = m.LargeAddedDataFiles.Size()
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *EmbeddedAddedDataFiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AddedDataFiles) > 0 {
		for _, e := range m.AddedDataFiles {
			l = e.Size()
			n += 1 + l + sovKinesis(uint64(l))
		}
	}
	return n
}

func (m *LargeAddedDataFiles) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func (m *AddedDataFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DataFilePathSuffix)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	if m.ManifestFilePosition != 0 {
		n += 1 + sovKinesis(uint64(m.ManifestFilePosition))
	}
	if m.TimestampFrom != 0 {
		n += 1 + sovKinesis(uint64(m.TimestampFrom))
	}
	if m.TimestampTo != 0 {
		n += 1 + sovKinesis(uint64(m.TimestampTo))
	}
	if m.RecordCount != 0 {
		n += 1 + sovKinesis(uint64(m.RecordCount))
	}
	if m.UncompressedSize != 0 {
		n += 1 + sovKinesis(uint64(m.UncompressedSize))
	}
	if m.CreationTime != 0 {
		n += 1 + sovKinesis(uint64(m.CreationTime))
	}
	if m.FileFormat != 0 {
		n += 1 + sovKinesis(uint64(m.FileFormat))
	}
	return n
}

func (m *SchemaReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovKinesis(uint64(l))
	}
	return n
}

func sovKinesis(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozKinesis(x uint64) (n int) {
	return sovKinesis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *DataFileEntryRecord) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataFileEntryRecord{`,
		`DataFileEntry:` + strings.Replace(this.DataFileEntry.String(), "DataFileEntry", "DataFileEntry", 1) + `,`,
		`DataFileInfo:` + strings.Replace(this.DataFileInfo.String(), "DataFileInfo", "DataFileInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataFileEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataFileEntry{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`StandardDataFileEntry:` + strings.Replace(this.StandardDataFileEntry.String(), "StandardDataFileEntry", "StandardDataFileEntry", 1) + `,`,
		`LargeDataFileEntry:` + strings.Replace(this.LargeDataFileEntry.String(), "LargeDataFileEntry", "LargeDataFileEntry", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StandardDataFileEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StandardDataFileEntry{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`DataFileV1:` + strings.Replace(this.DataFileV1.String(), "DataFileV1", "DataFileV1", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataFileV1) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSchemaReferences := "[]*SchemaReference{"
	for _, f := range this.SchemaReferences {
		repeatedStringForSchemaReferences += strings.Replace(f.String(), "SchemaReference", "SchemaReference", 1) + ","
	}
	repeatedStringForSchemaReferences += "}"
	keysForColumnSizes := make([]int32, 0, len(this.ColumnSizes))
	for k, _ := range this.ColumnSizes {
		keysForColumnSizes = append(keysForColumnSizes, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForColumnSizes)
	mapStringForColumnSizes := "map[int32]uint64{"
	for _, k := range keysForColumnSizes {
		mapStringForColumnSizes += fmt.Sprintf("%v: %v,", k, this.ColumnSizes[k])
	}
	mapStringForColumnSizes += "}"
	keysForValueCounts := make([]int32, 0, len(this.ValueCounts))
	for k, _ := range this.ValueCounts {
		keysForValueCounts = append(keysForValueCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForValueCounts)
	mapStringForValueCounts := "map[int32]uint64{"
	for _, k := range keysForValueCounts {
		mapStringForValueCounts += fmt.Sprintf("%v: %v,", k, this.ValueCounts[k])
	}
	mapStringForValueCounts += "}"
	keysForNullValueCounts := make([]int32, 0, len(this.NullValueCounts))
	for k, _ := range this.NullValueCounts {
		keysForNullValueCounts = append(keysForNullValueCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNullValueCounts)
	mapStringForNullValueCounts := "map[int32]uint64{"
	for _, k := range keysForNullValueCounts {
		mapStringForNullValueCounts += fmt.Sprintf("%v: %v,", k, this.NullValueCounts[k])
	}
	mapStringForNullValueCounts += "}"
	keysForNanValueCounts := make([]int32, 0, len(this.NanValueCounts))
	for k, _ := range this.NanValueCounts {
		keysForNanValueCounts = append(keysForNanValueCounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForNanValueCounts)
	mapStringForNanValueCounts := "map[int32]uint64{"
	for _, k := range keysForNanValueCounts {
		mapStringForNanValueCounts += fmt.Sprintf("%v: %v,", k, this.NanValueCounts[k])
	}
	mapStringForNanValueCounts += "}"
	keysForLowerBounds := make([]int32, 0, len(this.LowerBounds))
	for k, _ := range this.LowerBounds {
		keysForLowerBounds = append(keysForLowerBounds, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForLowerBounds)
	mapStringForLowerBounds := "map[int32][]byte{"
	for _, k := range keysForLowerBounds {
		mapStringForLowerBounds += fmt.Sprintf("%v: %v,", k, this.LowerBounds[k])
	}
	mapStringForLowerBounds += "}"
	keysForUpperBounds := make([]int32, 0, len(this.UpperBounds))
	for k, _ := range this.UpperBounds {
		keysForUpperBounds = append(keysForUpperBounds, k)
	}
	github_com_gogo_protobuf_sortkeys.Int32s(keysForUpperBounds)
	mapStringForUpperBounds := "map[int32][]byte{"
	for _, k := range keysForUpperBounds {
		mapStringForUpperBounds += fmt.Sprintf("%v: %v,", k, this.UpperBounds[k])
	}
	mapStringForUpperBounds += "}"
	s := strings.Join([]string{`&DataFileV1{`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`FileFormat:` + fmt.Sprintf("%v", this.FileFormat) + `,`,
		`RecordCount:` + fmt.Sprintf("%v", this.RecordCount) + `,`,
		`FileSizeInBytes:` + fmt.Sprintf("%v", this.FileSizeInBytes) + `,`,
		`ColumnSizes:` + mapStringForColumnSizes + `,`,
		`ValueCounts:` + mapStringForValueCounts + `,`,
		`NullValueCounts:` + mapStringForNullValueCounts + `,`,
		`NanValueCounts:` + mapStringForNanValueCounts + `,`,
		`LowerBounds:` + mapStringForLowerBounds + `,`,
		`UpperBounds:` + mapStringForUpperBounds + `,`,
		`IndexedFields:` + fmt.Sprintf("%v", this.IndexedFields) + `,`,
		`SchemaReferences:` + repeatedStringForSchemaReferences + `,`,
		`}`,
	}, "")
	return s
}
func (this *LargeDataFileEntry) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LargeDataFileEntry{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataFileInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataFileInfo{`,
		`FilePath:` + fmt.Sprintf("%v", this.FilePath) + `,`,
		`CreationTime:` + fmt.Sprintf("%v", this.CreationTime) + `,`,
		`AccountId:` + fmt.Sprintf("%v", this.AccountId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MetadataCommitRecord) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MetadataCommitRecord{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`IcebergCommitRecord:` + strings.Replace(this.IcebergCommitRecord.String(), "IcebergCommitRecord", "IcebergCommitRecord", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IcebergCommitRecord) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IcebergCommitRecord{`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`IcebergCommitRecordV1:` + strings.Replace(this.IcebergCommitRecordV1.String(), "IcebergCommitRecordV1", "IcebergCommitRecordV1", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IcebergCommitRecordV1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IcebergCommitRecordV1{`,
		`CommitInfo:` + strings.Replace(this.CommitInfo.String(), "IcebergCommitInfo", "IcebergCommitInfo", 1) + `,`,
		`FieldIndexInfo:` + strings.Replace(this.FieldIndexInfo.String(), "FieldIndexInfo", "FieldIndexInfo", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *IcebergCommitInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&IcebergCommitInfo{`,
		`ResourceInfo:` + strings.Replace(this.ResourceInfo.String(), "ResourceInfo", "ResourceInfo", 1) + `,`,
		`ManifestFileUpdate:` + strings.Replace(this.ManifestFileUpdate.String(), "ManifestFileUpdate", "ManifestFileUpdate", 1) + `,`,
		`CommitTimestamp:` + fmt.Sprintf("%v", this.CommitTimestamp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceInfo{`,
		`AccountId:` + fmt.Sprintf("%v", this.AccountId) + `,`,
		`LogGroupName:` + fmt.Sprintf("%v", this.LogGroupName) + `,`,
		`LogGroupInternalId:` + fmt.Sprintf("%v", this.LogGroupInternalId) + `,`,
		`SchemaId:` + fmt.Sprintf("%v", this.SchemaId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldIndexInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FieldIndexInfo{`,
		`IndexedFields:` + fmt.Sprintf("%v", this.IndexedFields) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ManifestFileUpdate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ManifestFileUpdate{`,
		`PreviousManifestFilePathSuffix:` + fmt.Sprintf("%v", this.PreviousManifestFilePathSuffix) + `,`,
		`NewManifestFilePathSuffix:` + fmt.Sprintf("%v", this.NewManifestFilePathSuffix) + `,`,
		`BaseLocation:` + fmt.Sprintf("%v", this.BaseLocation) + `,`,
		`AddedDataFiles:` + strings.Replace(this.AddedDataFiles.String(), "AddedDataFiles", "AddedDataFiles", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddedDataFiles) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddedDataFiles{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`EmbeddedAddedDataFiles:` + strings.Replace(this.EmbeddedAddedDataFiles.String(), "EmbeddedAddedDataFiles", "EmbeddedAddedDataFiles", 1) + `,`,
		`LargeAddedDataFiles:` + strings.Replace(this.LargeAddedDataFiles.String(), "LargeAddedDataFiles", "LargeAddedDataFiles", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmbeddedAddedDataFiles) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAddedDataFiles := "[]*AddedDataFile{"
	for _, f := range this.AddedDataFiles {
		repeatedStringForAddedDataFiles += strings.Replace(f.String(), "AddedDataFile", "AddedDataFile", 1) + ","
	}
	repeatedStringForAddedDataFiles += "}"
	s := strings.Join([]string{`&EmbeddedAddedDataFiles{`,
		`AddedDataFiles:` + repeatedStringForAddedDataFiles + `,`,
		`}`,
	}, "")
	return s
}
func (this *LargeAddedDataFiles) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LargeAddedDataFiles{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AddedDataFile) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AddedDataFile{`,
		`DataFilePathSuffix:` + fmt.Sprintf("%v", this.DataFilePathSuffix) + `,`,
		`ManifestFilePosition:` + fmt.Sprintf("%v", this.ManifestFilePosition) + `,`,
		`TimestampFrom:` + fmt.Sprintf("%v", this.TimestampFrom) + `,`,
		`TimestampTo:` + fmt.Sprintf("%v", this.TimestampTo) + `,`,
		`RecordCount:` + fmt.Sprintf("%v", this.RecordCount) + `,`,
		`UncompressedSize:` + fmt.Sprintf("%v", this.UncompressedSize) + `,`,
		`CreationTime:` + fmt.Sprintf("%v", this.CreationTime) + `,`,
		`FileFormat:` + fmt.Sprintf("%v", this.FileFormat) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SchemaReference) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SchemaReference{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringKinesis(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *DataFileEntryRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileEntryRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileEntryRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFileEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataFileEntry == nil {
				m.DataFileEntry = &DataFileEntry{}
			}
			if err := m.DataFileEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataFileInfo == nil {
				m.DataFileInfo = &DataFileInfo{}
			}
			if err := m.DataFileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFileEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DataFileEntry_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StandardDataFileEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StandardDataFileEntry == nil {
				m.StandardDataFileEntry = &StandardDataFileEntry{}
			}
			if err := m.StandardDataFileEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeDataFileEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LargeDataFileEntry == nil {
				m.LargeDataFileEntry = &LargeDataFileEntry{}
			}
			if err := m.LargeDataFileEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StandardDataFileEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StandardDataFileEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StandardDataFileEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= StandardDataFileEntry_Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFileV1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataFileV1 == nil {
				m.DataFileV1 = &DataFileV1{}
			}
			if err := m.DataFileV1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFileV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFormat", wireType)
			}
			m.FileFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileFormat |= FileFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCount", wireType)
			}
			m.RecordCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSizeInBytes", wireType)
			}
			m.FileSizeInBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSizeInBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnSizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ColumnSizes == nil {
				m.ColumnSizes = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKinesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKinesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKinesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKinesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ColumnSizes[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueCounts == nil {
				m.ValueCounts = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKinesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKinesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKinesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKinesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ValueCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullValueCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NullValueCounts == nil {
				m.NullValueCounts = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKinesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKinesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKinesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKinesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NullValueCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NanValueCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NanValueCounts == nil {
				m.NanValueCounts = make(map[int32]uint64)
			}
			var mapkey int32
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKinesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKinesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKinesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKinesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NanValueCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LowerBounds == nil {
				m.LowerBounds = make(map[int32][]byte)
			}
			var mapkey int32
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKinesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKinesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthKinesis
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthKinesis
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKinesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKinesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LowerBounds[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBounds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpperBounds == nil {
				m.UpperBounds = make(map[int32][]byte)
			}
			var mapkey int32
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKinesis
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = int32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKinesis
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthKinesis
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthKinesis
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKinesis(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKinesis
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UpperBounds[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedFields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexedFields = append(m.IndexedFields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaReferences = append(m.SchemaReferences, &SchemaReference{})
			if err := m.SchemaReferences[len(m.SchemaReferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LargeDataFileEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LargeDataFileEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LargeDataFileEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataFileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataFileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataFileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			m.CreationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataCommitRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataCommitRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataCommitRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MetadataCommitRecord_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcebergCommitRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IcebergCommitRecord == nil {
				m.IcebergCommitRecord = &IcebergCommitRecord{}
			}
			if err := m.IcebergCommitRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcebergCommitRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcebergCommitRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcebergCommitRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= IcebergCommitRecord_Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IcebergCommitRecordV1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IcebergCommitRecordV1 == nil {
				m.IcebergCommitRecordV1 = &IcebergCommitRecordV1{}
			}
			if err := m.IcebergCommitRecordV1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcebergCommitRecordV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcebergCommitRecordV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcebergCommitRecordV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitInfo == nil {
				m.CommitInfo = &IcebergCommitInfo{}
			}
			if err := m.CommitInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldIndexInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldIndexInfo == nil {
				m.FieldIndexInfo = &FieldIndexInfo{}
			}
			if err := m.FieldIndexInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IcebergCommitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IcebergCommitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IcebergCommitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceInfo == nil {
				m.ResourceInfo = &ResourceInfo{}
			}
			if err := m.ResourceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestFileUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManifestFileUpdate == nil {
				m.ManifestFileUpdate = &ManifestFileUpdate{}
			}
			if err := m.ManifestFileUpdate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTimestamp", wireType)
			}
			m.CommitTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogGroupInternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogGroupInternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldIndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldIndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldIndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedFields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexedFields = append(m.IndexedFields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManifestFileUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManifestFileUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManifestFileUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousManifestFilePathSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousManifestFilePathSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewManifestFilePathSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewManifestFilePathSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedDataFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddedDataFiles == nil {
				m.AddedDataFiles = &AddedDataFiles{}
			}
			if err := m.AddedDataFiles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddedDataFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddedDataFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddedDataFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= AddedDataFiles_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmbeddedAddedDataFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmbeddedAddedDataFiles == nil {
				m.EmbeddedAddedDataFiles = &EmbeddedAddedDataFiles{}
			}
			if err := m.EmbeddedAddedDataFiles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeAddedDataFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LargeAddedDataFiles == nil {
				m.LargeAddedDataFiles = &LargeAddedDataFiles{}
			}
			if err := m.LargeAddedDataFiles.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmbeddedAddedDataFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmbeddedAddedDataFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmbeddedAddedDataFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedDataFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddedDataFiles = append(m.AddedDataFiles, &AddedDataFile{})
			if err := m.AddedDataFiles[len(m.AddedDataFiles)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LargeAddedDataFiles) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LargeAddedDataFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LargeAddedDataFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddedDataFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddedDataFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddedDataFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilePathSuffix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilePathSuffix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestFilePosition", wireType)
			}
			m.ManifestFilePosition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManifestFilePosition |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampFrom", wireType)
			}
			m.TimestampFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampFrom |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampTo", wireType)
			}
			m.TimestampTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimestampTo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordCount", wireType)
			}
			m.RecordCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncompressedSize", wireType)
			}
			m.UncompressedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncompressedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			m.CreationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFormat", wireType)
			}
			m.FileFormat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileFormat |= FileFormat(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKinesis
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKinesis
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKinesis(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthKinesis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKinesis(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKinesis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKinesis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthKinesis
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthKinesis
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKinesis
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKinesis(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthKinesis
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKinesis = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKinesis   = fmt.Errorf("proto: integer overflow")
)
